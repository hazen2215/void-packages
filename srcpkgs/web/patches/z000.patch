diff --git b/platform/media/libcubeb/src/cubeb_audiounit.cpp a/platform/media/libcubeb/src/cubeb_audiounit.cpp
index 1893d1582a..9483c2795e 100644
--- b/platform/media/libcubeb/src/cubeb_audiounit.cpp
+++ a/platform/media/libcubeb/src/cubeb_audiounit.cpp
@@ -85,10 +85,8 @@ struct cubeb {
   cubeb_device_type collection_changed_devtype;
   uint32_t devtype_device_count;
   AudioObjectID * devtype_device_array;
-#ifndef __ppc__
   // The queue is asynchronously deallocated once all references to it are released
   dispatch_queue_t serial_queue = dispatch_queue_create(DISPATCH_QUEUE_LABEL, DISPATCH_QUEUE_SERIAL);
-#endif
 };
 
 class auto_array_wrapper
@@ -702,17 +700,13 @@ audiounit_property_listener_callback(AudioObjectID /* id */, UInt32 address_coun
 
   // Use a new thread, through the queue, to avoid deadlock when calling
   // Get/SetProperties method from inside notify callback
-#ifndef __ppc__
   dispatch_async(stm->context->serial_queue, ^() {
-#endif
     if (audiounit_reinit_stream(stm) != CUBEB_OK) {
       stm->state_callback(stm, stm->user_ptr, CUBEB_STATE_STOPPED);
       LOG("(%p) Could not reopen the stream after switching.", stm);
     }
     stm->switching_device = false;
-#ifndef __ppc__
   });
-#endif
 
   return noErr;
 }
@@ -1934,14 +1928,10 @@ audiounit_stream_destroy(cubeb_stream * stm)
 
   // Execute close in serial queue to avoid collision
   // with reinit when un/plug devices
-#ifndef __ppc__
   dispatch_sync(stm->context->serial_queue, ^() {
     auto_lock lock(stm->mutex);
-#endif
     audiounit_close_stream(stm);
-#ifndef __ppc__
   });
-#endif
 
   assert(stm->context->active_streams >= 1);
   stm->context->active_streams -= 1;

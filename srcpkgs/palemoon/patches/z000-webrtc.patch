diff --git a/palemoon/base/content/browser.js b/palemoon/base/content/browser.js
index 173101adb..161d7aaba 100644
--- a/palemoon/base/content/browser.js
+++ b/palemoon/base/content/browser.js
@@ -136,7 +136,7 @@ var gInitialPages = [
 #include browser-uacompat.js
 
 #ifdef MOZ_WEBRTC
-#include browser-webrtcUI.js
+// #include browser-webrtcUI.js
 #endif
 
 #include browser-gestureSupport.js
@@ -1099,7 +1099,7 @@ var gBrowserInit = {
     IndexedDBPromptHelper.init();
     AddonManager.addAddonListener(AddonsMgrListener);
 #ifdef MOZ_WEBRTC
-    WebrtcIndicator.init();
+    // WebrtcIndicator.init();
 #endif
 
     // Ensure login manager is up and running.
diff --git a/palemoon/base/content/content.js b/palemoon/base/content/content.js
index 33b774f90..cade1f9c9 100644
--- a/palemoon/base/content/content.js
+++ b/palemoon/base/content/content.js
@@ -8,6 +8,7 @@ var Ci = Components.interfaces;
 var Cu = Components.utils;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource:///modules/ContentWebRTC.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "BrowserUtils",
   "resource://gre/modules/BrowserUtils.jsm");
@@ -176,3 +177,17 @@ addMessageListener("Finder:Initialize", function() {
 addEventListener("DOMWebNotificationClicked", function(event) {
   sendAsyncMessage("DOMWebNotificationClicked", {});
 }, false);
+
+ContentWebRTC.init();
+addMessageListener("rtcpeer:Allow", ContentWebRTC);
+addMessageListener("rtcpeer:Deny", ContentWebRTC);
+addMessageListener("webrtc:Allow", ContentWebRTC);
+addMessageListener("webrtc:Deny", ContentWebRTC);
+addMessageListener("webrtc:StopSharing", ContentWebRTC);
+addMessageListener("webrtc:StartBrowserSharing", () => {
+  let windowID = content.QueryInterface(Ci.nsIInterfaceRequestor)
+                        .getInterface(Ci.nsIDOMWindowUtils).outerWindowID;
+  sendAsyncMessage("webrtc:response:StartBrowserSharing", {
+    windowID: windowID
+  });
+});
diff --git a/palemoon/base/content/popup-notifications.inc b/palemoon/base/content/popup-notifications.inc
index 31a72b489..b914cf07d 100644
--- a/palemoon/base/content/popup-notifications.inc
+++ b/palemoon/base/content/popup-notifications.inc
@@ -56,7 +56,6 @@
 #ifdef MOZ_WEBRTC
     <popupnotification id="webRTC-shareDevices-notification" hidden="true">
       <popupnotificationcontent id="webRTC-selectCamera" orient="vertical">
-        <separator class="thin"/>
         <label value="&getUserMedia.selectCamera.label;"
                accesskey="&getUserMedia.selectCamera.accesskey;"
                control="webRTC-selectCamera-menulist"/>
@@ -64,8 +63,26 @@
           <menupopup id="webRTC-selectCamera-menupopup"/>
         </menulist>
       </popupnotificationcontent>
+
+      <popupnotificationcontent id="webRTC-selectWindowOrScreen" orient="vertical">
+        <label id="webRTC-selectWindow-label"
+               control="webRTC-selectWindow-menulist"/>
+        <menulist id="webRTC-selectWindow-menulist"
+                  oncommand="webrtcUI.updateMainActionLabel(this);">
+          <menupopup id="webRTC-selectWindow-menupopup"/>
+        </menulist>
+        <description id="webRTC-all-windows-shared" hidden="true">&getUserMedia.allWindowsShared.message;</description>
+      </popupnotificationcontent>
+
+      <popupnotificationcontent id="webRTC-preview" hidden="true">
+        <html:video id="webRTC-previewVideo"/>
+        <vbox id="webRTC-previewWarningBox">
+          <spacer flex="1"/>
+          <description id="webRTC-previewWarning"/>
+        </vbox>
+      </popupnotificationcontent>
+
       <popupnotificationcontent id="webRTC-selectMicrophone" orient="vertical">
-        <separator class="thin"/>
         <label value="&getUserMedia.selectMicrophone.label;"
                accesskey="&getUserMedia.selectMicrophone.accesskey;"
                control="webRTC-selectMicrophone-menulist"/>
diff --git a/palemoon/base/content/tabbrowser.xml b/palemoon/base/content/tabbrowser.xml
index ee73946c0..efa13b671 100644
--- a/palemoon/base/content/tabbrowser.xml
+++ b/palemoon/base/content/tabbrowser.xml
@@ -2321,6 +2321,12 @@
               aOurTab.setAttribute("soundplaying", "true");
               modifiedAttrs.push("soundplaying");
             }
+            if (aOtherTab.hasAttribute("sharing")) {
+              aOurTab.setAttribute("sharing", aOtherTab.getAttribute("sharing"));
+              modifiedAttrs.push("sharing");
+              aOurTab._sharingState = aOtherTab._sharingState;
+              webrtcUI.swapBrowserForNotification(otherBrowser, ourBrowser);
+            }
 
             // If the other tab is pending (i.e. has not been restored, yet)
             // then do not switch docShells but retrieve the other tab's state
diff --git a/palemoon/base/content/webrtcIndicator.js b/palemoon/base/content/webrtcIndicator.js
new file mode 100644
index 000000000..301607031
--- /dev/null
+++ b/palemoon/base/content/webrtcIndicator.js
@@ -0,0 +1,194 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+var {classes: Cc, interfaces: Ci, utils: Cu} = Components;
+Cu.import("resource://gre/modules/Services.jsm");
+Cu.import("resource:///modules/webrtcUI.jsm");
+
+const BUNDLE_URL = "chrome://browser/locale/webrtcIndicator.properties";
+var gStringBundle;
+
+function init(event) {
+  gStringBundle = Services.strings.createBundle(BUNDLE_URL);
+
+  let brand = Services.strings.createBundle("chrome://branding/locale/brand.properties");
+  let brandShortName = brand.GetStringFromName("brandShortName");
+  document.title =
+    gStringBundle.formatStringFromName("webrtcIndicator.windowtitle",
+                                       [brandShortName], 1);
+
+  for (let id of ["audioVideoButton", "screenSharePopup"]) {
+    let popup = document.getElementById(id);
+    popup.addEventListener("popupshowing", onPopupMenuShowing);
+    popup.addEventListener("popuphiding", onPopupMenuHiding);
+    popup.addEventListener("command", onPopupMenuCommand);
+  }
+
+  let fxButton = document.getElementById("firefoxButton");
+  fxButton.addEventListener("click", onFirefoxButtonClick);
+  fxButton.addEventListener("mousedown", PositionHandler);
+
+  updateIndicatorState();
+
+  // Alert accessibility implementations stuff just changed. We only need to do
+  // this initially, because changes after this will automatically fire alert
+  // events if things change materially.
+  let ev = new CustomEvent("AlertActive", {bubbles: true, cancelable: true});
+  document.documentElement.dispatchEvent(ev);
+}
+
+function updateIndicatorState() {
+  updateWindowAttr("sharingvideo", webrtcUI.showCameraIndicator);
+  updateWindowAttr("sharingaudio", webrtcUI.showMicrophoneIndicator);
+  updateWindowAttr("sharingscreen", webrtcUI.showScreenSharingIndicator);
+
+  // Camera and microphone button tooltip.
+  let shareTypes = [];
+  if (webrtcUI.showCameraIndicator)
+    shareTypes.push("Camera");
+  if (webrtcUI.showMicrophoneIndicator)
+    shareTypes.push("Microphone");
+
+  let audioVideoButton = document.getElementById("audioVideoButton");
+  if (shareTypes.length) {
+    let stringId = "webrtcIndicator.sharing" + shareTypes.join("And") + ".tooltip";
+    audioVideoButton.setAttribute("tooltiptext",
+                                   gStringBundle.GetStringFromName(stringId));
+  }
+  else {
+    audioVideoButton.removeAttribute("tooltiptext");
+  }
+
+  // Screen sharing button tooltip.
+  let screenShareButton = document.getElementById("screenShareButton");
+  if (webrtcUI.showScreenSharingIndicator) {
+    let stringId = "webrtcIndicator.sharing" +
+      webrtcUI.showScreenSharingIndicator + ".tooltip";
+    screenShareButton.setAttribute("tooltiptext",
+                                    gStringBundle.GetStringFromName(stringId));
+  }
+  else {
+    screenShareButton.removeAttribute("tooltiptext");
+  }
+
+  // Resize and ensure the window position is correct
+  // (sizeToContent messes with our position).
+  window.sizeToContent();
+  PositionHandler.adjustPosition();
+}
+
+function updateWindowAttr(attr, value) {
+  let docEl = document.documentElement;
+  if (value)
+    docEl.setAttribute(attr, "true");
+  else
+    docEl.removeAttribute(attr);
+}
+
+function onPopupMenuShowing(event) {
+  let popup = event.target;
+  let type = popup.getAttribute("type");
+
+  let activeStreams;
+  if (type == "Devices")
+    activeStreams = webrtcUI.getActiveStreams(true, true, false);
+  else
+    activeStreams = webrtcUI.getActiveStreams(false, false, true);
+
+  if (activeStreams.length == 1) {
+    webrtcUI.showSharingDoorhanger(activeStreams[0], type);
+    event.preventDefault();
+    return;
+  }
+
+  for (let stream of activeStreams) {
+    let item = document.createElement("menuitem");
+    item.setAttribute("label", stream.browser.contentTitle || stream.uri);
+    item.setAttribute("tooltiptext", stream.uri);
+    item.stream = stream;
+    popup.appendChild(item);
+  }
+}
+
+function onPopupMenuHiding(event) {
+  let popup = event.target;
+  while (popup.firstChild)
+    popup.firstChild.remove();
+}
+
+function onPopupMenuCommand(event) {
+  let item = event.target;
+  webrtcUI.showSharingDoorhanger(item.stream,
+                                 item.parentNode.getAttribute("type"));
+}
+
+function onFirefoxButtonClick(event) {
+  event.target.blur();
+  let activeStreams = webrtcUI.getActiveStreams(true, true, true);
+  activeStreams[0].browser.ownerGlobal.focus();
+}
+
+var PositionHandler = {
+  positionCustomized: false,
+  threshold: 10,
+  adjustPosition: function() {
+    if (!this.positionCustomized) {
+      // Center the window horizontally on the screen (not the available area).
+      // Until we have moved the window to y=0, 'screen.width' may give a value
+      // for a secondary screen, so use values from the screen manager instead.
+      let primaryScreen = Cc["@mozilla.org/gfx/screenmanager;1"]
+                            .getService(Ci.nsIScreenManager)
+                            .primaryScreen;
+      let widthDevPix = {};
+      primaryScreen.GetRect({}, {}, widthDevPix, {});
+      let availTopDevPix = {};
+      primaryScreen.GetAvailRect({}, availTopDevPix, {}, {});
+      let scaleFactor = primaryScreen.defaultCSSScaleFactor;
+      let widthCss = widthDevPix.value / scaleFactor;
+      window.moveTo((widthCss - document.documentElement.clientWidth) / 2,
+                    availTopDevPix.value / scaleFactor);
+    } else {
+      // This will ensure we're at y=0.
+      this.setXPosition(window.screenX);
+    }
+  },
+  setXPosition: function(desiredX) {
+    // Ensure the indicator isn't moved outside the available area of the screen.
+    desiredX = Math.max(desiredX, screen.availLeft);
+    let maxX =
+      screen.availLeft + screen.availWidth - document.documentElement.clientWidth;
+    window.moveTo(Math.min(desiredX, maxX), screen.availTop);
+  },
+  handleEvent: function(aEvent) {
+    switch (aEvent.type) {
+      case "mousedown":
+        if (aEvent.button != 0 || aEvent.defaultPrevented)
+          return;
+
+        this._startMouseX = aEvent.screenX;
+        this._startWindowX = window.screenX;
+        this._deltaX = this._startMouseX - this._startWindowX;
+
+        window.addEventListener("mousemove", this);
+        window.addEventListener("mouseup", this);
+        break;
+
+      case "mousemove":
+        let moveOffset = Math.abs(aEvent.screenX - this._startMouseX);
+        if (this._dragFullyStarted || moveOffset > this.threshold) {
+          this.setXPosition(aEvent.screenX - this._deltaX);
+          this._dragFullyStarted = true;
+        }
+        break;
+
+      case "mouseup":
+        this._dragFullyStarted = false;
+        window.removeEventListener("mousemove", this);
+        window.removeEventListener("mouseup", this);
+        this.positionCustomized =
+          Math.abs(this._startWindowX - window.screenX) >= this.threshold;
+        break;
+    }
+  }
+};
diff --git a/palemoon/base/content/webrtcIndicator.xul b/palemoon/base/content/webrtcIndicator.xul
new file mode 100644
index 000000000..9208dc814
--- /dev/null
+++ b/palemoon/base/content/webrtcIndicator.xul
@@ -0,0 +1,35 @@
+<?xml version="1.0"?>
+
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+<?xml-stylesheet href="chrome://global/skin/" type="text/css"?>
+<?xml-stylesheet href="chrome://browser/skin/webRTC-indicator.css" type="text/css"?>
+
+<!DOCTYPE window>
+
+<window xmlns:html="http://www.w3.org/1999/xhtml"
+        xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        id="webrtcIndicator"
+        role="alert"
+        windowtype="Browser:WebRTCGlobalIndicator"
+        onload="init(event);"
+#ifdef XP_MACOSX
+        inwindowmenu="false"
+#endif
+        sizemode="normal"
+        hidechrome="true"
+        orient="horizontal"
+        >
+  <script type="application/javascript" src="chrome://browser/content/webrtcIndicator.js"/>
+
+  <button id="firefoxButton"/>
+  <button id="audioVideoButton" type="menu">
+    <menupopup id="audioVideoPopup" type="Devices"/>
+  </button>
+  <separator id="shareSeparator"/>
+  <button id="screenShareButton" type="menu">
+    <menupopup id="screenSharePopup" type="Screen"/>
+  </button>
+</window>
diff --git a/palemoon/base/jar.mn b/palemoon/base/jar.mn
index 17255ffff..412fa0274 100644
--- a/palemoon/base/jar.mn
+++ b/palemoon/base/jar.mn
@@ -72,6 +72,10 @@ browser.jar:
 * content/browser/jsConsoleOverlay.xul          (content/jsConsoleOverlay.xul)
 * content/browser/softwareUpdateOverlay.xul     (content/softwareUpdateOverlay.xul)
 #endif
+#ifndef XP_MACOSX
+*       content/browser/webrtcIndicator.xul           (content/webrtcIndicator.xul)
+        content/browser/webrtcIndicator.js            (content/webrtcIndicator.js)
+#endif
 * content/browser/viewSourceOverlay.xul         (content/viewSourceOverlay.xul)
 #ifdef XP_WIN
   content/browser/win6BrowserOverlay.xul        (content/win6BrowserOverlay.xul)
diff --git a/palemoon/locales/en-US/chrome/browser/webrtcIndicator.properties b/palemoon/locales/en-US/chrome/browser/webrtcIndicator.properties
new file mode 100644
index 000000000..71d6f2ed9
--- /dev/null
+++ b/palemoon/locales/en-US/chrome/browser/webrtcIndicator.properties
@@ -0,0 +1,61 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+# LOCALIZATION NOTE : FILE This file contains the webrtc global indicator strings
+
+# LOCALIZATION NOTE (webrtcIndicator.windowtitle): %S is the brand name (e.g. Firefox).
+# This string is used so that the window has a title in tools that enumerate/look for window
+# titles. It is not normally visible anywhere.
+webrtcIndicator.windowtitle = %S - Sharing Indicator
+
+webrtcIndicator.sharingCameraAndMicrophone.tooltip = Your camera and microphone are being shared. Click to control sharing.
+webrtcIndicator.sharingCamera.tooltip              = Your camera is being shared. Click to control sharing.
+webrtcIndicator.sharingMicrophone.tooltip          = Your microphone is being shared. Click to control sharing.
+webrtcIndicator.sharingApplication.tooltip = An application is being shared. Click to control sharing.
+webrtcIndicator.sharingScreen.tooltip = Your screen is being shared. Click to control sharing.
+webrtcIndicator.sharingWindow.tooltip = A window is being shared. Click to control sharing.
+webrtcIndicator.sharingBrowser.tooltip = A tab is being shared. Click to control sharing.
+
+
+# LOCALIZATION NOTE : The following strings are only used on Mac for
+# menus attached to icons near the clock on the mac menubar.
+
+# LOCALIZATION NOTE (webrtcIndicator.sharing*With.menuitem):
+# %S is the title of the tab using the share.
+webrtcIndicator.sharingCameraWith.menuitem = Sharing Camera with “%S”
+webrtcIndicator.sharingMicrophoneWith.menuitem = Sharing Microphone with “%S”
+webrtcIndicator.sharingApplicationWith.menuitem = Sharing an Application with “%S”
+webrtcIndicator.sharingScreenWith.menuitem = Sharing Screen with “%S”
+webrtcIndicator.sharingWindowWith.menuitem = Sharing a Window with “%S”
+webrtcIndicator.sharingBrowserWith.menuitem = Sharing a Tab with “%S”
+webrtcIndicator.controlSharing.menuitem = Control Sharing
+# LOCALIZATION NOTE (webrtcIndicator.sharingCameraWithNTabs.menuitem):
+# Semicolon-separated list of plural forms. See:
+# http://developer.mozilla.org/en/docs/Localization_and_Plurals
+webrtcIndicator.sharingCameraWithNTabs.menuitem = Sharing Camera with #1 tab;Sharing Camera with #1 tabs
+# LOCALIZATION NOTE (webrtcIndicator.sharingMicrophoneWithNTabs.menuitem):
+# Semicolon-separated list of plural forms. See:
+# http://developer.mozilla.org/en/docs/Localization_and_Plurals
+webrtcIndicator.sharingMicrophoneWithNTabs.menuitem = Sharing Microphone with #1 tab;Sharing Microphone with #1 tabs
+# LOCALIZATION NOTE (webrtcIndicator.sharingApplicationWithNTabs.menuitem):
+# Semicolon-separated list of plural forms. See:
+# http://developer.mozilla.org/en/docs/Localization_and_Plurals
+webrtcIndicator.sharingApplicationWithNTabs.menuitem = Sharing an Application with #1 tab;Sharing Applications with #1 tabs
+# LOCALIZATION NOTE (webrtcIndicator.sharingScreenWithNTabs.menuitem):
+# Semicolon-separated list of plural forms. See:
+# http://developer.mozilla.org/en/docs/Localization_and_Plurals
+webrtcIndicator.sharingScreenWithNTabs.menuitem = Sharing Screen with #1 tab;Sharing Screen with #1 tabs
+# LOCALIZATION NOTE (webrtcIndicator.sharingWindowWithNTabs.menuitem):
+# Semicolon-separated list of plural forms. See:
+# http://developer.mozilla.org/en/docs/Localization_and_Plurals
+webrtcIndicator.sharingWindowWithNTabs.menuitem = Sharing a Window with #1 tab;Sharing Windows with #1 tabs
+# LOCALIZATION NOTE (webrtcIndicator.sharingBrowserWithNTabs.menuitem):
+# Semicolon-separated list of plural forms. See:
+# http://developer.mozilla.org/en/docs/Localization_and_Plurals
+# This message is shown when the contents of a tab is shared during a WebRTC
+# session, which currently is only possible with Loop/Hello.
+webrtcIndicator.sharingBrowserWithNTabs.menuitem = Sharing a Tab with #1 tab;Sharing Tabs with #1 tabs
+# LOCALIZATION NOTE (webrtcIndicator.controlSharingOn.menuitem):
+# %S is the title of the tab using the share.
+webrtcIndicator.controlSharingOn.menuitem = Control Sharing on “%S”
diff --git a/palemoon/locales/jar.mn b/palemoon/locales/jar.mn
index 26cc88735..e06d97d16 100644
--- a/palemoon/locales/jar.mn
+++ b/palemoon/locales/jar.mn
@@ -45,6 +45,7 @@
   locale/browser/tabbrowser.dtd                                 (%chrome/browser/tabbrowser.dtd)
   locale/browser/tabbrowser.properties                          (%chrome/browser/tabbrowser.properties)
   locale/browser/taskbar.properties                             (%chrome/browser/taskbar.properties)
+  locale/browser/webrtcIndicator.properties                     (%chrome/browser/webrtcIndicator.properties)
   locale/browser/downloads/downloads.dtd                        (%chrome/browser/downloads/downloads.dtd)
   locale/browser/downloads/downloads.properties                 (%chrome/browser/downloads/downloads.properties)
   locale/browser/places/places.dtd                              (%chrome/browser/places/places.dtd)
diff --git a/palemoon/modules/ContentWebRTC.jsm b/palemoon/modules/ContentWebRTC.jsm
new file mode 100644
index 000000000..fd50176a0
--- /dev/null
+++ b/palemoon/modules/ContentWebRTC.jsm
@@ -0,0 +1,393 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const {classes: Cc, interfaces: Ci, results: Cr, utils: Cu} = Components;
+
+this.EXPORTED_SYMBOLS = [ "ContentWebRTC" ];
+
+Cu.import("resource://gre/modules/Services.jsm");
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+XPCOMUtils.defineLazyServiceGetter(this, "MediaManagerService",
+                                   "@mozilla.org/mediaManagerService;1",
+                                   "nsIMediaManagerService");
+
+const kBrowserURL = "chrome://browser/content/browser.xul";
+
+this.ContentWebRTC = {
+  _initialized: false,
+
+  init: function() {
+    if (this._initialized)
+      return;
+
+    this._initialized = true;
+    Services.obs.addObserver(handleGUMRequest, "getUserMedia:request", false);
+    Services.obs.addObserver(handlePCRequest, "PeerConnection:request", false);
+    Services.obs.addObserver(updateIndicators, "recording-device-events", false);
+    Services.obs.addObserver(removeBrowserSpecificIndicator, "recording-window-ended", false);
+
+    if (Services.appinfo.processType == Services.appinfo.PROCESS_TYPE_CONTENT)
+      Services.obs.addObserver(processShutdown, "content-child-shutdown", false);
+  },
+
+  uninit: function() {
+    Services.obs.removeObserver(handleGUMRequest, "getUserMedia:request");
+    Services.obs.removeObserver(handlePCRequest, "PeerConnection:request");
+    Services.obs.removeObserver(updateIndicators, "recording-device-events");
+    Services.obs.removeObserver(removeBrowserSpecificIndicator, "recording-window-ended");
+
+    if (Services.appinfo.processType == Services.appinfo.PROCESS_TYPE_CONTENT)
+      Services.obs.removeObserver(processShutdown, "content-child-shutdown");
+
+    this._initialized = false;
+  },
+
+  // Called only for 'unload' to remove pending gUM prompts in reloaded frames.
+  handleEvent: function(aEvent) {
+    let contentWindow = aEvent.target.defaultView;
+    let mm = getMessageManagerForWindow(contentWindow);
+    for (let key of contentWindow.pendingGetUserMediaRequests.keys()) {
+      mm.sendAsyncMessage("webrtc:CancelRequest", key);
+    }
+    for (let key of contentWindow.pendingPeerConnectionRequests.keys()) {
+      mm.sendAsyncMessage("rtcpeer:CancelRequest", key);
+    }
+  },
+
+  receiveMessage: function(aMessage) {
+    switch (aMessage.name) {
+      case "rtcpeer:Allow":
+      case "rtcpeer:Deny": {
+        let callID = aMessage.data.callID;
+        let contentWindow = Services.wm.getOuterWindowWithId(aMessage.data.windowID);
+        forgetPCRequest(contentWindow, callID);
+        let topic = (aMessage.name == "rtcpeer:Allow") ? "PeerConnection:response:allow" :
+                                                         "PeerConnection:response:deny";
+        Services.obs.notifyObservers(null, topic, callID);
+        break;
+      }
+      case "webrtc:Allow": {
+        let callID = aMessage.data.callID;
+        let contentWindow = Services.wm.getOuterWindowWithId(aMessage.data.windowID);
+        let devices = contentWindow.pendingGetUserMediaRequests.get(callID);
+        forgetGUMRequest(contentWindow, callID);
+
+        let allowedDevices = Cc["@mozilla.org/array;1"]
+                               .createInstance(Ci.nsIMutableArray);
+        for (let deviceIndex of aMessage.data.devices)
+           allowedDevices.appendElement(devices[deviceIndex], /* weak =*/ false);
+
+        Services.obs.notifyObservers(allowedDevices, "getUserMedia:response:allow", callID);
+        break;
+      }
+      case "webrtc:Deny":
+        denyGUMRequest(aMessage.data);
+        break;
+      case "webrtc:StopSharing":
+        Services.obs.notifyObservers(null, "getUserMedia:revoke", aMessage.data);
+        break;
+    }
+  }
+};
+
+function handlePCRequest(aSubject, aTopic, aData) {
+  let { windowID, innerWindowID, callID, isSecure } = aSubject;
+  let contentWindow = Services.wm.getOuterWindowWithId(windowID);
+
+  let mm = getMessageManagerForWindow(contentWindow);
+  if (!mm) {
+    // Workaround for Bug 1207784. To use WebRTC, add-ons right now use
+    // hiddenWindow.mozRTCPeerConnection which is only privileged on OSX. Other
+    // platforms end up here without a message manager.
+    // TODO: Remove once there's a better way (1215591).
+
+    // Skip permission check in the absence of a message manager.
+    Services.obs.notifyObservers(null, "PeerConnection:response:allow", callID);
+    return;
+  }
+
+  if (!contentWindow.pendingPeerConnectionRequests) {
+    setupPendingListsInitially(contentWindow);
+  }
+  contentWindow.pendingPeerConnectionRequests.add(callID);
+
+  let request = {
+    windowID: windowID,
+    innerWindowID: innerWindowID,
+    callID: callID,
+    documentURI: contentWindow.document.documentURI,
+    secure: isSecure,
+  };
+  mm.sendAsyncMessage("rtcpeer:Request", request);
+}
+
+function handleGUMRequest(aSubject, aTopic, aData) {
+  let constraints = aSubject.getConstraints();
+  let secure = aSubject.isSecure;
+  let contentWindow = Services.wm.getOuterWindowWithId(aSubject.windowID);
+
+  contentWindow.navigator.mozGetUserMediaDevices(
+    constraints,
+    function (devices) {
+      // If the window has been closed while we were waiting for the list of
+      // devices, there's nothing to do in the callback anymore.
+      if (contentWindow.closed)
+        return;
+
+      prompt(contentWindow, aSubject.windowID, aSubject.callID,
+             constraints, devices, secure);
+    },
+    function (error) {
+      // bug 827146 -- In the future, the UI should catch NotFoundError
+      // and allow the user to plug in a device, instead of immediately failing.
+      denyGUMRequest({callID: aSubject.callID}, error);
+    },
+    aSubject.innerWindowID,
+    aSubject.callID);
+}
+
+function prompt(aContentWindow, aWindowID, aCallID, aConstraints, aDevices, aSecure) {
+  let audioDevices = [];
+  let videoDevices = [];
+  let devices = [];
+
+  // MediaStreamConstraints defines video as 'boolean or MediaTrackConstraints'.
+  let video = aConstraints.video || aConstraints.picture;
+  let audio = aConstraints.audio;
+  let sharingScreen = video && typeof(video) != "boolean" &&
+                      video.mediaSource != "camera";
+  let sharingAudio = audio && typeof(audio) != "boolean" &&
+                     audio.mediaSource != "microphone";
+  for (let device of aDevices) {
+    device = device.QueryInterface(Ci.nsIMediaDevice);
+    switch (device.type) {
+      case "audio":
+        // Check that if we got a microphone, we have not requested an audio
+        // capture, and if we have requested an audio capture, we are not
+        // getting a microphone instead.
+        if (audio && (device.mediaSource == "microphone") != sharingAudio) {
+          audioDevices.push({name: device.name, deviceIndex: devices.length,
+                             id: device.rawId, mediaSource: device.mediaSource});
+          devices.push(device);
+        }
+        break;
+      case "video":
+        // Verify that if we got a camera, we haven't requested a screen share,
+        // or that if we requested a screen share we aren't getting a camera.
+        if (video && (device.mediaSource == "camera") != sharingScreen) {
+          let deviceObject = {name: device.name, deviceIndex: devices.length,
+                              id: device.rawId, mediaSource: device.mediaSource};
+          if (device.scary)
+            deviceObject.scary = true;
+          videoDevices.push(deviceObject);
+          devices.push(device);
+        }
+        break;
+    }
+  }
+
+  let requestTypes = [];
+  if (videoDevices.length)
+    requestTypes.push(sharingScreen ? "Screen" : "Camera");
+  if (audioDevices.length)
+    requestTypes.push(sharingAudio ? "AudioCapture" : "Microphone");
+
+  if (!requestTypes.length) {
+    denyGUMRequest({callID: aCallID}, "NotFoundError");
+    return;
+  }
+
+  if (!aContentWindow.pendingGetUserMediaRequests) {
+    setupPendingListsInitially(aContentWindow);
+  }
+  aContentWindow.pendingGetUserMediaRequests.set(aCallID, devices);
+
+  let request = {
+    callID: aCallID,
+    windowID: aWindowID,
+    origin: aContentWindow.origin,
+    documentURI: aContentWindow.document.documentURI,
+    secure: aSecure,
+    requestTypes: requestTypes,
+    sharingScreen: sharingScreen,
+    sharingAudio: sharingAudio,
+    audioDevices: audioDevices,
+    videoDevices: videoDevices
+  };
+
+  let mm = getMessageManagerForWindow(aContentWindow);
+  mm.sendAsyncMessage("webrtc:Request", request);
+}
+
+function denyGUMRequest(aData, aError) {
+  let msg = null;
+  if (aError) {
+    msg = Cc["@mozilla.org/supports-string;1"].createInstance(Ci.nsISupportsString);
+    msg.data = aError;
+  }
+  Services.obs.notifyObservers(msg, "getUserMedia:response:deny", aData.callID);
+
+  if (!aData.windowID)
+    return;
+  let contentWindow = Services.wm.getOuterWindowWithId(aData.windowID);
+  if (contentWindow.pendingGetUserMediaRequests)
+    forgetGUMRequest(contentWindow, aData.callID);
+}
+
+function forgetGUMRequest(aContentWindow, aCallID) {
+  aContentWindow.pendingGetUserMediaRequests.delete(aCallID);
+  forgetPendingListsEventually(aContentWindow);
+}
+
+function forgetPCRequest(aContentWindow, aCallID) {
+  aContentWindow.pendingPeerConnectionRequests.delete(aCallID);
+  forgetPendingListsEventually(aContentWindow);
+}
+
+function setupPendingListsInitially(aContentWindow) {
+  if (aContentWindow.pendingGetUserMediaRequests) {
+    return;
+  }
+  aContentWindow.pendingGetUserMediaRequests = new Map();
+  aContentWindow.pendingPeerConnectionRequests = new Set();
+  aContentWindow.addEventListener("unload", ContentWebRTC);
+}
+
+function forgetPendingListsEventually(aContentWindow) {
+  if (aContentWindow.pendingGetUserMediaRequests.size ||
+      aContentWindow.pendingPeerConnectionRequests.size) {
+    return;
+  }
+  aContentWindow.pendingGetUserMediaRequests = null;
+  aContentWindow.pendingPeerConnectionRequests = null;
+  aContentWindow.removeEventListener("unload", ContentWebRTC);
+}
+
+function updateIndicators(aSubject, aTopic, aData) {
+  if (aSubject instanceof Ci.nsIPropertyBag &&
+      aSubject.getProperty("requestURL") == kBrowserURL) {
+    // Ignore notifications caused by the browser UI showing previews.
+    return;
+  }
+
+  let contentWindowArray = MediaManagerService.activeMediaCaptureWindows;
+  let count = contentWindowArray.length;
+
+  let state = {
+    showGlobalIndicator: count > 0,
+    showCameraIndicator: false,
+    showMicrophoneIndicator: false,
+    showScreenSharingIndicator: ""
+  };
+
+  let cpmm = Cc["@mozilla.org/childprocessmessagemanager;1"]
+               .getService(Ci.nsIMessageSender);
+  cpmm.sendAsyncMessage("webrtc:UpdatingIndicators");
+
+  // If several iframes in the same page use media streams, it's possible to
+  // have the same top level window several times. We use a Set to avoid
+  // sending duplicate notifications.
+  let contentWindows = new Set();
+  for (let i = 0; i < count; ++i) {
+    contentWindows.add(contentWindowArray.queryElementAt(i, Ci.nsISupports).top);
+  }
+
+  for (let contentWindow of contentWindows) {
+    if (contentWindow.document.documentURI == kBrowserURL) {
+      // There may be a preview shown at the same time as other streams.
+      continue;
+    }
+
+    let tabState = getTabStateForContentWindow(contentWindow);
+    if (tabState.camera)
+      state.showCameraIndicator = true;
+    if (tabState.microphone)
+      state.showMicrophoneIndicator = true;
+    if (tabState.screen) {
+      if (tabState.screen == "Screen") {
+        state.showScreenSharingIndicator = "Screen";
+      }
+      else if (tabState.screen == "Window") {
+        if (state.showScreenSharingIndicator != "Screen")
+          state.showScreenSharingIndicator = "Window";
+      }
+      else if (tabState.screen == "Application") {
+        if (!state.showScreenSharingIndicator)
+          state.showScreenSharingIndicator = "Application";
+      }
+      else if (tabState.screen == "Browser") {
+        if (!state.showScreenSharingIndicator)
+          state.showScreenSharingIndicator = "Browser";
+      }
+    }
+    let mm = getMessageManagerForWindow(contentWindow);
+    mm.sendAsyncMessage("webrtc:UpdateBrowserIndicators", tabState);
+  }
+
+  cpmm.sendAsyncMessage("webrtc:UpdateGlobalIndicators", state);
+}
+
+function removeBrowserSpecificIndicator(aSubject, aTopic, aData) {
+  let contentWindow = Services.wm.getOuterWindowWithId(aData).top;
+  if (contentWindow.document.documentURI == kBrowserURL) {
+    // Ignore notifications caused by the browser UI showing previews.
+    return;
+  }
+
+  let tabState = getTabStateForContentWindow(contentWindow);
+  if (!tabState.camera && !tabState.microphone && !tabState.screen)
+    tabState = {windowId: tabState.windowId};
+
+  let mm = getMessageManagerForWindow(contentWindow);
+  if (mm)
+    mm.sendAsyncMessage("webrtc:UpdateBrowserIndicators", tabState);
+}
+
+function getTabStateForContentWindow(aContentWindow) {
+  let camera = {}, microphone = {}, screen = {}, window = {}, app = {}, browser = {};
+  MediaManagerService.mediaCaptureWindowState(aContentWindow, camera, microphone,
+                                              screen, window, app, browser);
+  let tabState = {camera: camera.value, microphone: microphone.value};
+  if (screen.value)
+    tabState.screen = "Screen";
+  else if (window.value)
+    tabState.screen = "Window";
+  else if (app.value)
+    tabState.screen = "Application";
+  else if (browser.value)
+    tabState.screen = "Browser";
+
+  tabState.windowId = getInnerWindowIDForWindow(aContentWindow);
+  tabState.documentURI = aContentWindow.document.documentURI;
+
+  return tabState;
+}
+
+function getInnerWindowIDForWindow(aContentWindow) {
+  return aContentWindow.QueryInterface(Ci.nsIInterfaceRequestor)
+                       .getInterface(Ci.nsIDOMWindowUtils)
+                       .currentInnerWindowID;
+}
+
+function getMessageManagerForWindow(aContentWindow) {
+  let ir = aContentWindow.QueryInterface(Ci.nsIInterfaceRequestor)
+                         .getInterface(Ci.nsIDocShell)
+                         .sameTypeRootTreeItem
+                         .QueryInterface(Ci.nsIInterfaceRequestor);
+  try {
+    // If e10s is disabled, this throws NS_NOINTERFACE for closed tabs.
+    return ir.getInterface(Ci.nsIContentFrameMessageManager);
+  } catch (e) {
+    if (e.result == Cr.NS_NOINTERFACE) {
+      return null;
+    }
+    throw e;
+  }
+}
+
+function processShutdown() {
+  ContentWebRTC.uninit();
+}
diff --git a/palemoon/modules/moz.build b/palemoon/modules/moz.build
index ec2ef0fb5..1821071f6 100644
--- a/palemoon/modules/moz.build
+++ b/palemoon/modules/moz.build
@@ -7,6 +7,7 @@ EXTRA_JS_MODULES += [
     'AutoCompletePopup.jsm',
     'BrowserNewTabPreloader.jsm',
     'CharsetMenu.jsm',
+    'ContentWebRTC.jsm',
     'FormSubmitObserver.jsm',
     'FormValidationHandler.jsm',
     'NetworkPrioritizer.jsm',
diff --git a/palemoon/modules/webrtcUI.jsm b/palemoon/modules/webrtcUI.jsm
index 819ca181f..08de46bb3 100644
--- a/palemoon/modules/webrtcUI.jsm
+++ b/palemoon/modules/webrtcUI.jsm
@@ -13,51 +13,243 @@ const Ci = Components.interfaces;
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
+XPCOMUtils.defineLazyModuleGetter(this, "AppConstants",
+                                  "resource://gre/modules/AppConstants.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "PluralForm",
                                   "resource://gre/modules/PluralForm.jsm");
 
-XPCOMUtils.defineLazyServiceGetter(this, "MediaManagerService",
-                                   "@mozilla.org/mediaManagerService;1",
-                                   "nsIMediaManagerService");
-
 this.webrtcUI = {
   init: function () {
-    Services.obs.addObserver(handleRequest, "getUserMedia:request", false);
-    Services.obs.addObserver(updateIndicators, "recording-device-events", false);
-    Services.obs.addObserver(removeBrowserSpecificIndicator, "recording-window-ended", false);
+    Services.obs.addObserver(maybeAddMenuIndicator, "browser-delayed-startup-finished", false);
+
+    let ppmm = Cc["@mozilla.org/parentprocessmessagemanager;1"]
+                 .getService(Ci.nsIMessageBroadcaster);
+    ppmm.addMessageListener("webrtc:UpdatingIndicators", this);
+    ppmm.addMessageListener("webrtc:UpdateGlobalIndicators", this);
+    ppmm.addMessageListener("child-process-shutdown", this);
+
+    let mm = Cc["@mozilla.org/globalmessagemanager;1"]
+               .getService(Ci.nsIMessageListenerManager);
+    mm.addMessageListener("rtcpeer:Request", this);
+    mm.addMessageListener("rtcpeer:CancelRequest", this);
+    mm.addMessageListener("webrtc:Request", this);
+    mm.addMessageListener("webrtc:CancelRequest", this);
+    mm.addMessageListener("webrtc:UpdateBrowserIndicators", this);
   },
 
   uninit: function () {
-    Services.obs.removeObserver(handleRequest, "getUserMedia:request");
-    Services.obs.removeObserver(updateIndicators, "recording-device-events");
-    Services.obs.removeObserver(removeBrowserSpecificIndicator, "recording-window-ended");
+    Services.obs.removeObserver(maybeAddMenuIndicator, "browser-delayed-startup-finished");
+
+    let ppmm = Cc["@mozilla.org/parentprocessmessagemanager;1"]
+                 .getService(Ci.nsIMessageBroadcaster);
+    ppmm.removeMessageListener("webrtc:UpdatingIndicators", this);
+    ppmm.removeMessageListener("webrtc:UpdateGlobalIndicators", this);
+
+    let mm = Cc["@mozilla.org/globalmessagemanager;1"]
+               .getService(Ci.nsIMessageListenerManager);
+    mm.removeMessageListener("rtcpeer:Request", this);
+    mm.removeMessageListener("rtcpeer:CancelRequest", this);
+    mm.removeMessageListener("webrtc:Request", this);
+    mm.removeMessageListener("webrtc:CancelRequest", this);
+    mm.removeMessageListener("webrtc:UpdateBrowserIndicators", this);
+
+    if (gIndicatorWindow) {
+      gIndicatorWindow.close();
+      gIndicatorWindow = null;
+    }
+  },
+
+  processIndicators: new Map(),
+
+  get showGlobalIndicator() {
+    for (let [, indicators] of this.processIndicators) {
+      if (indicators.showGlobalIndicator)
+        return true;
+    }
+    return false;
+  },
+
+  get showCameraIndicator() {
+    for (let [, indicators] of this.processIndicators) {
+      if (indicators.showCameraIndicator)
+        return true;
+    }
+    return false;
+  },
+
+  get showMicrophoneIndicator() {
+    for (let [, indicators] of this.processIndicators) {
+      if (indicators.showMicrophoneIndicator)
+        return true;
+    }
+    return false;
   },
 
-  showGlobalIndicator: false,
+  get showScreenSharingIndicator() {
+    let list = [""];
+    for (let [, indicators] of this.processIndicators) {
+      if (indicators.showScreenSharingIndicator)
+        list.push(indicators.showScreenSharingIndicator);
+    }
+
+    let precedence =
+      ["Screen", "Window", "Application", "Browser", ""];
+
+    list.sort((a, b) => { return precedence.indexOf(a) -
+                                 precedence.indexOf(b); });
+
+    return list[0];
+  },
 
-  get activeStreams() {
-    let contentWindowSupportsArray = MediaManagerService.activeMediaCaptureWindows;
-    let count = contentWindowSupportsArray.Count();
-    let activeStreams = [];
-    for (let i = 0; i < count; i++) {
-      let contentWindow = contentWindowSupportsArray.GetElementAt(i);
-      let browser = getBrowserForWindow(contentWindow);
-      let browserWindow = browser.ownerDocument.defaultView;
+  _streams: [],
+  // The boolean parameters indicate which streams should be included in the result.
+  getActiveStreams: function(aCamera, aMicrophone, aScreen) {
+    return webrtcUI._streams.filter(aStream => {
+      let state = aStream.state;
+      return aCamera && state.camera ||
+             aMicrophone && state.microphone ||
+             aScreen && state.screen;
+    }).map(aStream => {
+      let state = aStream.state;
+      let types = {camera: state.camera, microphone: state.microphone,
+                   screen: state.screen};
+      let browser = aStream.browser;
+      let browserWindow = browser.ownerGlobal;
       let tab = browserWindow.gBrowser &&
-                browserWindow.gBrowser._getTabForContentWindow(contentWindow.top);
-      activeStreams.push({
-        uri: contentWindow.location.href,
-        tab: tab,
-        browser: browser
+                browserWindow.gBrowser.getTabForBrowser(browser);
+      return {uri: state.documentURI, tab: tab, browser: browser, types: types};
+    });
+  },
+
+  swapBrowserForNotification: function(aOldBrowser, aNewBrowser) {
+    for (let stream of this._streams) {
+      if (stream.browser == aOldBrowser)
+        stream.browser = aNewBrowser;
+    }
+  },
+
+  forgetStreamsFromBrowser: function(aBrowser) {
+    this._streams = this._streams.filter(stream => stream.browser != aBrowser);
+  },
+
+  showSharingDoorhanger: function(aActiveStream, aType) {
+    let browserWindow = aActiveStream.browser.ownerGlobal;
+    if (aActiveStream.tab) {
+      browserWindow.gBrowser.selectedTab = aActiveStream.tab;
+    } else {
+      aActiveStream.browser.focus();
+    }
+    browserWindow.focus();
+    let identityBox = browserWindow.document.getElementById("identity-box");
+    if (AppConstants.platform == "macosx" && !Services.focus.activeWindow) {
+      browserWindow.addEventListener("activate", function onActivate() {
+        browserWindow.removeEventListener("activate", onActivate);
+        Services.tm.mainThread.dispatch(function() {
+          identityBox.click();
+        }, Ci.nsIThread.DISPATCH_NORMAL);
       });
+      Cc["@mozilla.org/widget/macdocksupport;1"].getService(Ci.nsIMacDockSupport)
+        .activateApplication(true);
+      return;
     }
-    return activeStreams;
-  }
-}
+    identityBox.click();
+  },
 
-function getBrowserForWindowId(aWindowID) {
-  return getBrowserForWindow(Services.wm.getOuterWindowWithId(aWindowID));
-}
+  updateMainActionLabel: function(aMenuList) {
+    let type = aMenuList.selectedItem.getAttribute("devicetype");
+    let document = aMenuList.ownerDocument;
+    document.getElementById("webRTC-all-windows-shared").hidden = type != "Screen";
+
+    // If we are also requesting audio in addition to screen sharing,
+    // always use a generic label.
+    if (!document.getElementById("webRTC-selectMicrophone").hidden)
+      type = "";
+
+    let bundle = document.defaultView.gNavigatorBundle;
+    let stringId = "getUserMedia.share" + (type || "SelectedItems") + ".label";
+    let popupnotification = aMenuList.parentNode.parentNode;
+    popupnotification.setAttribute("buttonlabel", bundle.getString(stringId));
+  },
+
+  receiveMessage: function(aMessage) {
+    switch (aMessage.name) {
+
+      // Add-ons can override stock permission behavior by doing:
+      //
+      //   var stockReceiveMessage = webrtcUI.receiveMessage;
+      //
+      //   webrtcUI.receiveMessage = function(aMessage) {
+      //     switch (aMessage.name) {
+      //      case "rtcpeer:Request": {
+      //        // new code.
+      //        break;
+      //      ...
+      //      default:
+      //        return stockReceiveMessage.call(this, aMessage);
+      //
+      // Intercepting gUM and peerConnection requests should let an add-on
+      // limit PeerConnection activity with automatic rules and/or prompts
+      // in a sensible manner that avoids double-prompting in typical
+      // gUM+PeerConnection scenarios. For example:
+      //
+      //   State                                    Sample Action
+      //   --------------------------------------------------------------
+      //   No IP leaked yet + No gUM granted        Warn user
+      //   No IP leaked yet + gUM granted           Avoid extra dialog
+      //   No IP leaked yet + gUM request pending.  Delay until gUM grant
+      //   IP already leaked                        Too late to warn
+
+      case "rtcpeer:Request": {
+        // Always allow. This code-point exists for add-ons to override.
+        let { callID, windowID } = aMessage.data;
+        // Also available: isSecure, innerWindowID. For contentWindow:
+        //
+        //   let contentWindow = Services.wm.getOuterWindowWithId(windowID);
+
+        let mm = aMessage.target.messageManager;
+        mm.sendAsyncMessage("rtcpeer:Allow",
+                            { callID: callID, windowID: windowID });
+        break;
+      }
+      case "rtcpeer:CancelRequest":
+        // No data to release. This code-point exists for add-ons to override.
+        break;
+      case "webrtc:Request":
+        prompt(aMessage.target, aMessage.data);
+        break;
+      case "webrtc:CancelRequest":
+        removePrompt(aMessage.target, aMessage.data);
+        break;
+      case "webrtc:UpdatingIndicators":
+        webrtcUI._streams = [];
+        break;
+      case "webrtc:UpdateGlobalIndicators":
+        updateIndicators(aMessage.data, aMessage.target);
+        break;
+      case "webrtc:UpdateBrowserIndicators":
+        let id = aMessage.data.windowId;
+        let index;
+        for (index = 0; index < webrtcUI._streams.length; ++index) {
+          if (webrtcUI._streams[index].state.windowId == id)
+            break;
+        }
+        // If there's no documentURI, the update is actually a removal of the
+        // stream, triggered by the recording-window-ended notification.
+        if (!aMessage.data.documentURI && index < webrtcUI._streams.length)
+          webrtcUI._streams.splice(index, 1);
+        else
+          webrtcUI._streams[index] = {browser: aMessage.target, state: aMessage.data};
+        let tabbrowser = aMessage.target.ownerGlobal.gBrowser;
+        if (tabbrowser)
+          tabbrowser.setBrowserSharing(aMessage.target, aMessage.data);
+        break;
+      case "child-process-shutdown":
+        webrtcUI.processIndicators.delete(aMessage.target);
+        updateIndicators(null, null);
+        break;
+    }
+  }
+};
 
 function getBrowserForWindow(aContentWindow) {
   return aContentWindow.QueryInterface(Ci.nsIInterfaceRequestor)
@@ -66,73 +258,63 @@ function getBrowserForWindow(aContentWindow) {
                        .chromeEventHandler;
 }
 
-function handleRequest(aSubject, aTopic, aData) {
-  let {windowID: windowID, callID: callID} = JSON.parse(aData);
-
-  let params = aSubject.QueryInterface(Ci.nsIMediaStreamOptions);
-
-  Services.wm.getMostRecentWindow(null).navigator.mozGetUserMediaDevices(
-    function (devices) {
-      prompt(windowID, callID, params.audio, params.video || params.picture, devices);
-    },
-    function (error) {
-      // bug 827146 -- In the future, the UI should catch NO_DEVICES_FOUND
-      // and allow the user to plug in a device, instead of immediately failing.
-      denyRequest(callID, error);
-    }
-  );
+function denyRequest(aBrowser, aRequest) {
+  aBrowser.messageManager.sendAsyncMessage("webrtc:Deny",
+                                           {callID: aRequest.callID,
+                                            windowID: aRequest.windowID});
 }
 
-function denyRequest(aCallID, aError) {
-  let msg = null;
-  if (aError) {
-    msg = Cc["@mozilla.org/supports-string;1"].createInstance(Ci.nsISupportsString);
-    msg.data = aError;
-  }
-  Services.obs.notifyObservers(msg, "getUserMedia:response:deny", aCallID);
-}
-
-function prompt(aWindowID, aCallID, aAudioRequested, aVideoRequested, aDevices) {
-  let audioDevices = [];
-  let videoDevices = [];
-  for (let device of aDevices) {
-    device = device.QueryInterface(Ci.nsIMediaDevice);
-    switch (device.type) {
-      case "audio":
-        if (aAudioRequested)
-          audioDevices.push(device);
-        break;
-      case "video":
-        if (aVideoRequested)
-          videoDevices.push(device);
-        break;
+function getHost(uri, href) {
+  let host;
+  try {
+    if (!uri) {
+      uri = Services.io.newURI(href, null, null);
+    }
+    host = uri.host;
+  } catch (ex) {}
+  if (!host) {
+    if (uri && uri.scheme.toLowerCase() == "about") {
+      // For about URIs, just use the full spec, without any #hash parts.
+      host = uri.specIgnoringRef;
+    } else {
+      // This is unfortunate, but we should display *something*...
+      const kBundleURI = "chrome://browser/locale/browser.properties";
+      let bundle = Services.strings.createBundle(kBundleURI);
+      host = bundle.GetStringFromName("getUserMedia.sharingMenuUnknownHost");
     }
   }
+  return host;
+}
 
-  let requestType;
-  if (audioDevices.length && videoDevices.length)
-    requestType = "CameraAndMicrophone";
-  else if (audioDevices.length)
-    requestType = "Microphone";
-  else if (videoDevices.length)
-    requestType = "Camera";
-  else {
-    denyRequest(aCallID, "NO_DEVICES_FOUND");
-    return;
+function prompt(aBrowser, aRequest) {
+  let {audioDevices: audioDevices, videoDevices: videoDevices,
+       sharingScreen: sharingScreen, sharingAudio: sharingAudio,
+       requestTypes: requestTypes} = aRequest;
+  let uri;
+  try {
+    // This fails for principals that serialize to "null", e.g. file URIs.
+    uri = Services.io.newURI(aRequest.origin, null, null);
+  } catch (e) {
+    uri = Services.io.newURI(aRequest.documentURI, null, null);
   }
-
-  let contentWindow = Services.wm.getOuterWindowWithId(aWindowID);
-  let host = contentWindow.document.documentURIObject.host;
-  let browser = getBrowserForWindow(contentWindow);
-  let chromeDoc = browser.ownerDocument;
+  let host = getHost(uri);
+  let chromeDoc = aBrowser.ownerDocument;
   let chromeWin = chromeDoc.defaultView;
   let stringBundle = chromeWin.gNavigatorBundle;
-  let message = stringBundle.getFormattedString("getUserMedia.share" + requestType + ".message",
-                                                [ host ]);
+  let stringId = "getUserMedia.share" + requestTypes.join("And") + ".message";
+  let message = stringBundle.getFormattedString(stringId, [host]);
+
+  let mainLabel;
+  if (sharingScreen || sharingAudio) {
+    mainLabel = stringBundle.getString("getUserMedia.shareSelectedItems.label");
+  } else {
+    let string = stringBundle.getString("getUserMedia.shareSelectedDevices.label");
+    mainLabel = PluralForm.get(requestTypes.length, string);
+  }
 
+  let notification; // Used by action callbacks.
   let mainAction = {
-    label: PluralForm.get(requestType == "CameraAndMicrophone" ? 2 : 1,
-                          stringBundle.getString("getUserMedia.shareSelectedDevices.label")),
+    label: mainLabel,
     accessKey: stringBundle.getString("getUserMedia.shareSelectedDevices.accesskey"),
     // The real callback will be set during the "showing" event. The
     // empty function here is so that PopupNotifications.show doesn't
@@ -140,153 +322,648 @@ function prompt(aWindowID, aCallID, aAudioRequested, aVideoRequested, aDevices)
     callback: function() {}
   };
 
-  let secondaryActions = [{
-    label: stringBundle.getString("getUserMedia.denyRequest.label"),
-    accessKey: stringBundle.getString("getUserMedia.denyRequest.accesskey"),
-    callback: function () {
-      denyRequest(aCallID);
+  let secondaryActions = [
+    {
+      label: stringBundle.getString("getUserMedia.denyRequest.label"),
+      accessKey: stringBundle.getString("getUserMedia.denyRequest.accesskey"),
+      callback: function () {
+        denyRequest(notification.browser, aRequest);
+      }
     }
-  }];
+  ];
+  // Bug 1037438: implement 'never' for screen sharing.
+  if (!sharingScreen && !sharingAudio) {
+    secondaryActions.push({
+      label: stringBundle.getString("getUserMedia.never.label"),
+      accessKey: stringBundle.getString("getUserMedia.never.accesskey"),
+      callback: function () {
+        denyRequest(notification.browser, aRequest);
+        // Let someone save "Never" for http sites so that they can be stopped from
+        // bothering you with doorhangers.
+        let perms = Services.perms;
+        if (audioDevices.length)
+          perms.add(uri, "microphone", perms.DENY_ACTION);
+        if (videoDevices.length)
+          perms.add(uri, "camera", perms.DENY_ACTION);
+      }
+    });
+  }
+
+  if (aRequest.secure && !sharingScreen && !sharingAudio) {
+    // Don't show the 'Always' action if the connection isn't secure, or for
+    // screen/audio sharing (because we can't guess which window the user wants
+    // to share without prompting).
+    secondaryActions.unshift({
+      label: stringBundle.getString("getUserMedia.always.label"),
+      accessKey: stringBundle.getString("getUserMedia.always.accesskey"),
+      callback: function (aState) {
+        mainAction.callback(aState, true);
+      }
+    });
+  }
 
   let options = {
     eventCallback: function(aTopic, aNewBrowser) {
       if (aTopic == "swapping")
         return true;
 
+      let chromeDoc = this.browser.ownerDocument;
+
+      // Clean-up video streams of screensharing previews.
+      if ((aTopic == "dismissed" || aTopic == "removed") &&
+          requestTypes.includes("Screen")) {
+        let video = chromeDoc.getElementById("webRTC-previewVideo");
+        video.deviceId = undefined;
+        if (video.stream) {
+          video.stream.getTracks().forEach(t => t.stop());
+          video.stream = null;
+          video.src = null;
+          chromeDoc.getElementById("webRTC-preview").hidden = true;
+        }
+        let menupopup = chromeDoc.getElementById("webRTC-selectWindow-menupopup");
+        if (menupopup._commandEventListener) {
+          menupopup.removeEventListener("command", menupopup._commandEventListener);
+          menupopup._commandEventListener = null;
+        }
+      }
+
       if (aTopic != "showing")
         return false;
 
-      let chromeDoc = this.browser.ownerDocument;
+      // DENY_ACTION is handled immediately by MediaManager, but handling
+      // of ALLOW_ACTION is delayed until the popupshowing event
+      // to avoid granting permissions automatically to background tabs.
+      if (aRequest.secure) {
+        let perms = Services.perms;
+
+        let micPerm = perms.testExactPermission(uri, "microphone");
+        if (micPerm == perms.PROMPT_ACTION)
+          micPerm = perms.UNKNOWN_ACTION;
+
+        let camPerm = perms.testExactPermission(uri, "camera");
+
+        let mediaManagerPerm =
+          perms.testExactPermission(uri, "MediaManagerVideo");
+        if (mediaManagerPerm) {
+          perms.remove(uri, "MediaManagerVideo");
+        }
+
+        if (camPerm == perms.PROMPT_ACTION)
+          camPerm = perms.UNKNOWN_ACTION;
+
+        // Screen sharing shouldn't follow the camera permissions.
+        if (videoDevices.length && sharingScreen)
+          camPerm = perms.UNKNOWN_ACTION;
+
+        // We don't check that permissions are set to ALLOW_ACTION in this
+        // test; only that they are set. This is because if audio is allowed
+        // and video is denied persistently, we don't want to show the prompt,
+        // and will grant audio access immediately.
+        if ((!audioDevices.length || micPerm) && (!videoDevices.length || camPerm)) {
+          // All permissions we were about to request are already persistently set.
+          let allowedDevices = [];
+          if (videoDevices.length && camPerm == perms.ALLOW_ACTION) {
+            allowedDevices.push(videoDevices[0].deviceIndex);
+            let perms = Services.perms;
+            perms.add(uri, "MediaManagerVideo", perms.ALLOW_ACTION,
+                      perms.EXPIRE_SESSION);
+          }
+          if (audioDevices.length && micPerm == perms.ALLOW_ACTION)
+            allowedDevices.push(audioDevices[0].deviceIndex);
+
+          // Remember on which URIs we found persistent permissions so that we
+          // can remove them if the user clicks 'Stop Sharing'. There's no
+          // other way for the stop sharing code to know the hostnames of frames
+          // using devices until bug 1066082 is fixed.
+          let browser = this.browser;
+          browser._devicePermissionURIs = browser._devicePermissionURIs || [];
+          browser._devicePermissionURIs.push(uri);
+
+          let mm = browser.messageManager;
+          mm.sendAsyncMessage("webrtc:Allow", {callID: aRequest.callID,
+                                               windowID: aRequest.windowID,
+                                               devices: allowedDevices});
+          this.remove();
+          return true;
+        }
+      }
 
       function listDevices(menupopup, devices) {
         while (menupopup.lastChild)
           menupopup.removeChild(menupopup.lastChild);
 
-        let deviceIndex = 0;
-        for (let device of devices) {
-          addDeviceToList(menupopup, device.name, deviceIndex);
-          deviceIndex++;
+        for (let device of devices)
+          addDeviceToList(menupopup, device.name, device.deviceIndex);
+      }
+
+      function listScreenShareDevices(menupopup, devices) {
+        while (menupopup.lastChild)
+          menupopup.removeChild(menupopup.lastChild);
+
+        let type = devices[0].mediaSource;
+        let typeName = type.charAt(0).toUpperCase() + type.substr(1);
+
+        let label = chromeDoc.getElementById("webRTC-selectWindow-label");
+        let stringId = "getUserMedia.select" + typeName;
+        label.setAttribute("value",
+                           stringBundle.getString(stringId + ".label"));
+        label.setAttribute("accesskey",
+                           stringBundle.getString(stringId + ".accesskey"));
+
+        // "No <type>" is the default because we can't pick a
+        // 'default' window to share.
+        addDeviceToList(menupopup,
+                        stringBundle.getString("getUserMedia.no" + typeName + ".label"),
+                        "-1");
+        menupopup.appendChild(chromeDoc.createElement("menuseparator"));
+
+        // Build the list of 'devices'.
+        let monitorIndex = 1;
+        for (let i = 0; i < devices.length; ++i) {
+          let device = devices[i];
+
+          let name;
+          // Building screen list from available screens.
+          if (type == "screen") {
+            if (device.name == "Primary Monitor") {
+              name = stringBundle.getString("getUserMedia.shareEntireScreen.label");
+            } else {
+              name = stringBundle.getFormattedString("getUserMedia.shareMonitor.label",
+                                                     [monitorIndex]);
+              ++monitorIndex;
+            }
+          }
+          else {
+            name = device.name;
+            if (type == "application") {
+              // The application names returned by the platform are of the form:
+              // <window count>\x1e<application name>
+              let sepIndex = name.indexOf("\x1e");
+              let count = name.slice(0, sepIndex);
+              let stringId = "getUserMedia.shareApplicationWindowCount.label";
+              name = PluralForm.get(parseInt(count), stringBundle.getString(stringId))
+                               .replace("#1", name.slice(sepIndex + 1))
+                               .replace("#2", count);
+            }
+          }
+          let item = addDeviceToList(menupopup, name, i, typeName);
+          item.deviceId = device.id;
+          if (device.scary)
+            item.scary = true;
         }
+
+        // Always re-select the "No <type>" item.
+        chromeDoc.getElementById("webRTC-selectWindow-menulist").removeAttribute("value");
+        chromeDoc.getElementById("webRTC-all-windows-shared").hidden = true;
+        menupopup._commandEventListener = event => {
+          let video = chromeDoc.getElementById("webRTC-previewVideo");
+          if (video.stream) {
+            video.stream.getTracks().forEach(t => t.stop());
+            video.stream = null;
+          }
+
+          let deviceId = event.target.deviceId;
+          if (deviceId == undefined) {
+            chromeDoc.getElementById("webRTC-preview").hidden = true;
+            video.src = null;
+            return;
+          }
+
+          let scary = event.target.scary;
+          let warning = chromeDoc.getElementById("webRTC-previewWarning");
+          warning.hidden = !scary;
+          let chromeWin = chromeDoc.defaultView;
+          if (scary) {
+            warning.hidden = false;
+            let string;
+            let bundle = chromeWin.gNavigatorBundle;
+
+            let learnMoreText =
+              bundle.getString("getUserMedia.shareScreen.learnMoreLabel");
+            let baseURL =
+              Services.urlFormatter.formatURLPref("app.support.baseURL");
+            let learnMore =
+              "<label class='text-link' href='" + baseURL + "screenshare-safety'>" +
+              learnMoreText + "</label>";
+
+            if (type == "screen") {
+              string = bundle.getFormattedString("getUserMedia.shareScreenWarning.message",
+                                                 [learnMore]);
+            }
+            else {
+              let brand =
+                chromeDoc.getElementById("bundle_brand").getString("brandShortName");
+              string = bundle.getFormattedString("getUserMedia.shareFirefoxWarning.message",
+                                                 [brand, learnMore]);
+            }
+            warning.innerHTML = string;
+          }
+
+          let perms = Services.perms;
+          let chromeUri = Services.io.newURI(chromeDoc.documentURI, null, null);
+          perms.add(chromeUri, "MediaManagerVideo", perms.ALLOW_ACTION,
+                    perms.EXPIRE_SESSION);
+
+          video.deviceId = deviceId;
+          let constraints = { video: { mediaSource: type, deviceId: {exact: deviceId } } };
+          chromeWin.navigator.mediaDevices.getUserMedia(constraints).then(stream => {
+            if (video.deviceId != deviceId) {
+              // The user has selected a different device or closed the panel
+              // before getUserMedia finished.
+              stream.getTracks().forEach(t => t.stop());
+              return;
+            }
+            video.src = chromeWin.URL.createObjectURL(stream);
+            video.stream = stream;
+            chromeDoc.getElementById("webRTC-preview").hidden = false;
+            video.onloadedmetadata = function(e) {
+              video.play();
+            };
+          });
+        };
+        menupopup.addEventListener("command", menupopup._commandEventListener);
       }
 
-      function addDeviceToList(menupopup, deviceName, deviceIndex) {
+      function addDeviceToList(menupopup, deviceName, deviceIndex, type) {
         let menuitem = chromeDoc.createElement("menuitem");
         menuitem.setAttribute("value", deviceIndex);
         menuitem.setAttribute("label", deviceName);
         menuitem.setAttribute("tooltiptext", deviceName);
+        if (type)
+          menuitem.setAttribute("devicetype", type);
         menupopup.appendChild(menuitem);
+        return menuitem;
       }
 
-      chromeDoc.getElementById("webRTC-selectCamera").hidden = !videoDevices.length;
-      chromeDoc.getElementById("webRTC-selectMicrophone").hidden = !audioDevices.length;
+      chromeDoc.getElementById("webRTC-selectCamera").hidden = !videoDevices.length || sharingScreen;
+      chromeDoc.getElementById("webRTC-selectWindowOrScreen").hidden = !sharingScreen || !videoDevices.length;
+      chromeDoc.getElementById("webRTC-selectMicrophone").hidden = !audioDevices.length || sharingAudio;
 
       let camMenupopup = chromeDoc.getElementById("webRTC-selectCamera-menupopup");
+      let windowMenupopup = chromeDoc.getElementById("webRTC-selectWindow-menupopup");
       let micMenupopup = chromeDoc.getElementById("webRTC-selectMicrophone-menupopup");
-      listDevices(camMenupopup, videoDevices);
-      listDevices(micMenupopup, audioDevices);
-      if (requestType == "CameraAndMicrophone") {
-        let stringBundle = chromeDoc.defaultView.gNavigatorBundle;
-        addDeviceToList(camMenupopup, stringBundle.getString("getUserMedia.noVideo.label"), "-1");
-        addDeviceToList(micMenupopup, stringBundle.getString("getUserMedia.noAudio.label"), "-1");
-      }
+      if (sharingScreen)
+        listScreenShareDevices(windowMenupopup, videoDevices);
+      else
+        listDevices(camMenupopup, videoDevices);
 
-      this.mainAction.callback = function() {
-        let allowedDevices = Cc["@mozilla.org/supports-array;1"]
-                               .createInstance(Ci.nsISupportsArray);
+      if (!sharingAudio)
+        listDevices(micMenupopup, audioDevices);
+
+      this.mainAction.callback = function(aState, aRemember) {
+        let allowedDevices = [];
+        let perms = Services.perms;
         if (videoDevices.length) {
-          let videoDeviceIndex = chromeDoc.getElementById("webRTC-selectCamera-menulist").value;
-          if (videoDeviceIndex != "-1")
-            allowedDevices.AppendElement(videoDevices[videoDeviceIndex]);
+          let listId = "webRTC-select" + (sharingScreen ? "Window" : "Camera") + "-menulist";
+          let videoDeviceIndex = chromeDoc.getElementById(listId).value;
+          let allowCamera = videoDeviceIndex != "-1";
+          if (allowCamera) {
+            allowedDevices.push(videoDeviceIndex);
+            // Session permission will be removed after use
+            // (it's really one-shot, not for the entire session)
+            perms.add(uri, "MediaManagerVideo", perms.ALLOW_ACTION,
+                      perms.EXPIRE_SESSION);
+          }
+          if (aRemember) {
+            perms.add(uri, "camera",
+                      allowCamera ? perms.ALLOW_ACTION : perms.DENY_ACTION);
+          }
         }
         if (audioDevices.length) {
-          let audioDeviceIndex = chromeDoc.getElementById("webRTC-selectMicrophone-menulist").value;
-          if (audioDeviceIndex != "-1")
-            allowedDevices.AppendElement(audioDevices[audioDeviceIndex]);
+          if (!sharingAudio) {
+            let audioDeviceIndex = chromeDoc.getElementById("webRTC-selectMicrophone-menulist").value;
+            let allowMic = audioDeviceIndex != "-1";
+            if (allowMic)
+              allowedDevices.push(audioDeviceIndex);
+            if (aRemember) {
+              perms.add(uri, "microphone",
+                        allowMic ? perms.ALLOW_ACTION : perms.DENY_ACTION);
+            }
+          } else {
+            // Only one device possible for audio capture.
+            allowedDevices.push(0);
+          }
         }
 
-        if (allowedDevices.Count() == 0) {
-          denyRequest(aCallID);
+        if (!allowedDevices.length) {
+          denyRequest(notification.browser, aRequest);
           return;
         }
 
-        Services.obs.notifyObservers(allowedDevices, "getUserMedia:response:allow", aCallID);
+        if (aRemember) {
+          // Remember on which URIs we set persistent permissions so that we
+          // can remove them if the user clicks 'Stop Sharing'.
+          aBrowser._devicePermissionURIs = aBrowser._devicePermissionURIs || [];
+          aBrowser._devicePermissionURIs.push(uri);
+        }
+
+        let mm = notification.browser.messageManager;
+        mm.sendAsyncMessage("webrtc:Allow", {callID: aRequest.callID,
+                                             windowID: aRequest.windowID,
+                                             devices: allowedDevices});
       };
+      return false;
+    }
+  };
+
+  let iconType = "Devices";
+  if (requestTypes.length == 1 && (requestTypes[0] == "Microphone" ||
+                                   requestTypes[0] == "AudioCapture"))
+    iconType = "Microphone";
+  if (requestTypes.includes("Screen"))
+    iconType = "Screen";
+  let anchorId = "webRTC-share" + iconType + "-notification-icon";
+
+  let iconClass = iconType.toLowerCase();
+  if (iconClass == "devices")
+    iconClass = "camera";
+  options.popupIconClass = iconClass + "-icon";
+
+  notification =
+    chromeWin.PopupNotifications.show(aBrowser, "webRTC-shareDevices", message,
+                                      anchorId, mainAction, secondaryActions,
+                                      options);
+  notification.callID = aRequest.callID;
+}
+
+function removePrompt(aBrowser, aCallId) {
+  let chromeWin = aBrowser.ownerGlobal;
+  let notification =
+    chromeWin.PopupNotifications.getNotification("webRTC-shareDevices", aBrowser);
+  if (notification && notification.callID == aCallId)
+    notification.remove();
+}
+
+function getGlobalIndicator() {
+  if (AppConstants.platform != "macosx") {
+    const INDICATOR_CHROME_URI = "chrome://browser/content/webrtcIndicator.xul";
+    const features = "chrome,dialog=yes,titlebar=no,popup=yes";
+
+    return Services.ww.openWindow(null, INDICATOR_CHROME_URI, "_blank", features, []);
+  }
+
+  let indicator = {
+    _camera: null,
+    _microphone: null,
+    _screen: null,
+
+    _hiddenDoc: Cc["@mozilla.org/appshell/appShellService;1"]
+                  .getService(Ci.nsIAppShellService)
+                  .hiddenDOMWindow.document,
+    _statusBar: Cc["@mozilla.org/widget/macsystemstatusbar;1"]
+                  .getService(Ci.nsISystemStatusBar),
+
+    _command: function(aEvent) {
+      let type = this.getAttribute("type");
+      if (type == "Camera" || type == "Microphone")
+        type = "Devices";
+      else if (type == "Window" || type == "Application" || type == "Browser")
+        type = "Screen";
+      webrtcUI.showSharingDoorhanger(aEvent.target.stream, type);
+    },
+
+    _popupShowing: function(aEvent) {
+      let type = this.getAttribute("type");
+      let activeStreams;
+      if (type == "Camera") {
+        activeStreams = webrtcUI.getActiveStreams(true, false, false);
+      }
+      else if (type == "Microphone") {
+        activeStreams = webrtcUI.getActiveStreams(false, true, false);
+      }
+      else if (type == "Screen") {
+        activeStreams = webrtcUI.getActiveStreams(false, false, true);
+        type = webrtcUI.showScreenSharingIndicator;
+      }
+
+      let bundle =
+        Services.strings.createBundle("chrome://browser/locale/webrtcIndicator.properties");
+
+      if (activeStreams.length == 1) {
+        let stream = activeStreams[0];
+
+        let menuitem = this.ownerDocument.createElement("menuitem");
+        let labelId = "webrtcIndicator.sharing" + type + "With.menuitem";
+        let label = stream.browser.contentTitle || stream.uri;
+        menuitem.setAttribute("label", bundle.formatStringFromName(labelId, [label], 1));
+        menuitem.setAttribute("disabled", "true");
+        this.appendChild(menuitem);
+
+        menuitem = this.ownerDocument.createElement("menuitem");
+        menuitem.setAttribute("label",
+                              bundle.GetStringFromName("webrtcIndicator.controlSharing.menuitem"));
+        menuitem.setAttribute("type", type);
+        menuitem.stream = stream;
+        menuitem.addEventListener("command", indicator._command);
+
+        this.appendChild(menuitem);
+        return true;
+      }
+
+      // We show a different menu when there are several active streams.
+      let menuitem = this.ownerDocument.createElement("menuitem");
+      let labelId = "webrtcIndicator.sharing" + type + "WithNTabs.menuitem";
+      let count = activeStreams.length;
+      let label = PluralForm.get(count, bundle.GetStringFromName(labelId)).replace("#1", count);
+      menuitem.setAttribute("label", label);
+      menuitem.setAttribute("disabled", "true");
+      this.appendChild(menuitem);
+
+      for (let stream of activeStreams) {
+        let item = this.ownerDocument.createElement("menuitem");
+        let labelId = "webrtcIndicator.controlSharingOn.menuitem";
+        let label = stream.browser.contentTitle || stream.uri;
+        item.setAttribute("label", bundle.formatStringFromName(labelId, [label], 1));
+        item.setAttribute("type", type);
+        item.stream = stream;
+        item.addEventListener("command", indicator._command);
+        this.appendChild(item);
+      }
+
       return true;
+    },
+
+    _popupHiding: function(aEvent) {
+      while (this.firstChild)
+        this.firstChild.remove();
+    },
+
+    _setIndicatorState: function(aName, aState) {
+      let field = "_" + aName.toLowerCase();
+      if (aState && !this[field]) {
+        let menu = this._hiddenDoc.createElement("menu");
+        menu.setAttribute("id", "webRTC-sharing" + aName + "-menu");
+
+        // The CSS will only be applied if the menu is actually inserted in the DOM.
+        this._hiddenDoc.documentElement.appendChild(menu);
+
+        this._statusBar.addItem(menu);
+
+        let menupopup = this._hiddenDoc.createElement("menupopup");
+        menupopup.setAttribute("type", aName);
+        menupopup.addEventListener("popupshowing", this._popupShowing);
+        menupopup.addEventListener("popuphiding", this._popupHiding);
+        menupopup.addEventListener("command", this._command);
+        menu.appendChild(menupopup);
+
+        this[field] = menu;
+      }
+      else if (this[field] && !aState) {
+        this._statusBar.removeItem(this[field]);
+        this[field].remove();
+        this[field] = null
+      }
+    },
+    updateIndicatorState: function() {
+      this._setIndicatorState("Camera", webrtcUI.showCameraIndicator);
+      this._setIndicatorState("Microphone", webrtcUI.showMicrophoneIndicator);
+      this._setIndicatorState("Screen", webrtcUI.showScreenSharingIndicator);
+    },
+    close: function() {
+      this._setIndicatorState("Camera", false);
+      this._setIndicatorState("Microphone", false);
+      this._setIndicatorState("Screen", false);
     }
   };
 
-  chromeWin.PopupNotifications.show(browser, "webRTC-shareDevices", message,
-                                    "webRTC-shareDevices-notification-icon", mainAction,
-                                    secondaryActions, options);
+  indicator.updateIndicatorState();
+  return indicator;
 }
 
-function updateIndicators() {
-  webrtcUI.showGlobalIndicator =
-    MediaManagerService.activeMediaCaptureWindows.Count() > 0;
+function onTabSharingMenuPopupShowing(e) {
+  let streams = webrtcUI.getActiveStreams(true, true, true);
+  for (let streamInfo of streams) {
+    let stringName = "getUserMedia.sharingMenu";
+    let types = streamInfo.types;
+    if (types.camera)
+      stringName += "Camera";
+    if (types.microphone)
+      stringName += "Microphone";
+    if (types.screen)
+      stringName += types.screen;
+
+    let doc = e.target.ownerDocument;
+    let bundle = doc.defaultView.gNavigatorBundle;
+
+    let origin = getHost(null, streamInfo.uri);
+    let menuitem = doc.createElement("menuitem");
+    menuitem.setAttribute("label", bundle.getFormattedString(stringName, [origin]));
+    menuitem.stream = streamInfo;
+
+    // We can only open 1 doorhanger at a time. Guessing that users would be
+    // most eager to control screen/window/app sharing, and only then
+    // camera/microphone sharing, in that (decreasing) order of priority.
+    let doorhangerType;
+    if ((/Screen|Window|Application/).test(stringName)) {
+      doorhangerType = "Screen";
+    } else {
+      doorhangerType = "Devices";
+    }
+    menuitem.setAttribute("doorhangertype", doorhangerType);
+    menuitem.addEventListener("command", onTabSharingMenuPopupCommand);
+    e.target.appendChild(menuitem);
+  }
+}
 
-  let e = Services.wm.getEnumerator("navigator:browser");
-  while (e.hasMoreElements())
-    e.getNext().WebrtcIndicator.updateButton();
+function onTabSharingMenuPopupHiding(e) {
+  while (this.lastChild)
+    this.lastChild.remove();
+}
 
-  for (let {browser: browser} of webrtcUI.activeStreams)
-    showBrowserSpecificIndicator(browser);
+function onTabSharingMenuPopupCommand(e) {
+  let type = e.target.getAttribute("doorhangertype");
+  webrtcUI.showSharingDoorhanger(e.target.stream, type);
 }
 
-function showBrowserSpecificIndicator(aBrowser) {
-  let hasVideo = {};
-  let hasAudio = {};
-  MediaManagerService.mediaCaptureWindowState(aBrowser.contentWindow,
-                                              hasVideo, hasAudio);
-  let captureState;
-  if (hasVideo.value && hasAudio.value) {
-    captureState = "CameraAndMicrophone";
-  } else if (hasVideo.value) {
-    captureState = "Camera";
-  } else if (hasAudio.value) {
-    captureState = "Microphone";
+function showOrCreateMenuForWindow(aWindow) {
+  let document = aWindow.document;
+  let menu = document.getElementById("tabSharingMenu");
+  if (!menu) {
+    let stringBundle = aWindow.gNavigatorBundle;
+    menu = document.createElement("menu");
+    menu.id = "tabSharingMenu";
+    let labelStringId = "getUserMedia.sharingMenu.label";
+    menu.setAttribute("label", stringBundle.getString(labelStringId));
+
+    let container, insertionPoint;
+    if (AppConstants.platform == "macosx") {
+      container = document.getElementById("windowPopup");
+      insertionPoint = document.getElementById("sep-window-list");
+      let separator = document.createElement("menuseparator");
+      separator.id = "tabSharingSeparator";
+      container.insertBefore(separator, insertionPoint);
+    } else {
+      let accesskeyStringId = "getUserMedia.sharingMenu.accesskey";
+      menu.setAttribute("accesskey", stringBundle.getString(accesskeyStringId));
+      container = document.getElementById("main-menubar");
+      insertionPoint = document.getElementById("helpMenu");
+    }
+    let popup = document.createElement("menupopup");
+    popup.id = "tabSharingMenuPopup";
+    popup.addEventListener("popupshowing", onTabSharingMenuPopupShowing);
+    popup.addEventListener("popuphiding", onTabSharingMenuPopupHiding);
+    menu.appendChild(popup);
+    container.insertBefore(menu, insertionPoint);
   } else {
-    Cu.reportError("showBrowserSpecificIndicator: got neither video nor audio access");
-    return;
+    menu.hidden = false;
+    if (AppConstants.platform == "macosx") {
+      document.getElementById("tabSharingSeparator").hidden = false;
+    }
   }
+}
 
-  let chromeWin = aBrowser.ownerDocument.defaultView;
-  let stringBundle = chromeWin.gNavigatorBundle;
+function maybeAddMenuIndicator(window) {
+  if (webrtcUI.showGlobalIndicator) {
+    showOrCreateMenuForWindow(window);
+  }
+}
 
-  let message = stringBundle.getString("getUserMedia.sharing" + captureState + ".message2");
+var gIndicatorWindow = null;
+
+function updateIndicators(data, target) {
+  if (data) {
+    // the global indicators specific to this process
+    let indicators;
+    if (webrtcUI.processIndicators.has(target)) {
+      indicators = webrtcUI.processIndicators.get(target);
+    } else {
+      indicators = {};
+      webrtcUI.processIndicators.set(target, indicators);
+    }
 
-  let windowId = aBrowser.contentWindow
-                         .QueryInterface(Ci.nsIInterfaceRequestor)
-                         .getInterface(Ci.nsIDOMWindowUtils)
-                         .currentInnerWindowID;
-  let mainAction = {
-    label: "Continue Sharing", //stringBundle.getString("getUserMedia.continueSharing.label"),
-    accessKey: "C", //stringBundle.getString("getUserMedia.continueSharing.accesskey"),
-    callback: function () {},
-    dismiss: true
-  };
-  let secondaryActions = [{
-    label: "Stop Sharing", //stringBundle.getString("getUserMedia.stopSharing.label"),
-    accessKey: "S", //stringBundle.getString("getUserMedia.stopSharing.accesskey"),
-    callback: function () {
-      Services.obs.notifyObservers(null, "getUserMedia:revoke", windowId);
+    indicators.showGlobalIndicator = data.showGlobalIndicator;
+    indicators.showCameraIndicator = data.showCameraIndicator;
+    indicators.showMicrophoneIndicator = data.showMicrophoneIndicator;
+    indicators.showScreenSharingIndicator = data.showScreenSharingIndicator;
+  }
+
+  let browserWindowEnum = Services.wm.getEnumerator("navigator:browser");
+  while (browserWindowEnum.hasMoreElements()) {
+    let chromeWin = browserWindowEnum.getNext();
+    if (webrtcUI.showGlobalIndicator) {
+      showOrCreateMenuForWindow(chromeWin);
+    } else {
+      let doc = chromeWin.document;
+      let existingMenu = doc.getElementById("tabSharingMenu");
+      if (existingMenu) {
+        existingMenu.hidden = true;
+      }
+      if (AppConstants.platform == "macosx") {
+        let separator = doc.getElementById("tabSharingSeparator");
+        if (separator) {
+          separator.hidden = true;
+        }
+      }
     }
-  }];
-  let options = {
-    hideNotNow: true,
-    dismissed: true,
-    eventCallback: function(aTopic) aTopic == "swapping"
-  };
-  chromeWin.PopupNotifications.show(aBrowser, "webRTC-sharingDevices", message,
-                                    "webRTC-sharingDevices-notification-icon", mainAction,
-                                    secondaryActions, options);
-}
+  }
 
-function removeBrowserSpecificIndicator(aSubject, aTopic, aData) {
-  let browser = getBrowserForWindowId(aData);
-  let PopupNotifications = browser.ownerDocument.defaultView.PopupNotifications;
-  let notification = PopupNotifications &&
-                     PopupNotifications.getNotification("webRTC-sharingDevices",
-                                                        browser);
-  if (notification)
-    PopupNotifications.remove(notification);
+  if (webrtcUI.showGlobalIndicator) {
+    if (!gIndicatorWindow)
+      gIndicatorWindow = getGlobalIndicator();
+    else
+      gIndicatorWindow.updateIndicatorState();
+  } else if (gIndicatorWindow) {
+    gIndicatorWindow.close();
+    gIndicatorWindow = null;
+  }
 }
diff --git a/palemoon/themes/linux/jar.mn b/palemoon/themes/linux/jar.mn
index f148bdb85..6e4ef7b01 100644
--- a/palemoon/themes/linux/jar.mn
+++ b/palemoon/themes/linux/jar.mn
@@ -55,6 +55,7 @@ browser.jar:
   skin/classic/browser/web-notifications-icon.svg
   skin/classic/browser/web-notifications-tray.svg
 #ifdef MOZ_WEBRTC
+  skin/classic/browser/webRTC-indicator.css
   skin/classic/browser/webRTC-shareDevice-16.png
   skin/classic/browser/webRTC-shareDevice-64.png
   skin/classic/browser/webRTC-sharingDevice-16.png
diff --git a/palemoon/themes/linux/webRTC-indicator.css b/palemoon/themes/linux/webRTC-indicator.css
new file mode 100644
index 000000000..c22f942ec
--- /dev/null
+++ b/palemoon/themes/linux/webRTC-indicator.css
@@ -0,0 +1,116 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+window {
+  border: 1px solid #ff9500;
+}
+
+#audioVideoButton,
+#screenShareButton,
+#firefoxButton {
+  height: 29px;
+  margin: 0;
+  -moz-appearance: none;
+  border-style: none;
+}
+
+#firefoxButton {
+  background-image: url("chrome://branding/content/icon48.png");
+  background-repeat: no-repeat;
+  background-size: 22px;
+  background-position: center center;
+  min-width: 29px;
+  background-color: white;
+}
+
+#firefoxButton:hover {
+  background-color: #f2f2f2;
+}
+
+#screenShareButton {
+  background-image: url("webRTC-screen-white-16.png");
+  background-position: center center;
+  background-repeat: no-repeat;
+  background-size: 16px;
+  min-width: 27px;
+  display: none;
+}
+
+window[sharingscreen] > #screenShareButton {
+  display: -moz-box;
+}
+
+#audioVideoButton {
+  display: none;
+  background-repeat: no-repeat;
+}
+
+/* When screen sharing, need to pull in the separator: */
+window[sharingscreen] > #audioVideoButton {
+  margin-right: -1px;
+}
+
+/* Single icon button: */
+window[sharingvideo] > #audioVideoButton,
+window[sharingaudio] > #audioVideoButton {
+  display: -moz-box;
+  background-position: center center;
+  background-size: 16px;
+  min-width: 26px;
+}
+
+window[sharingvideo] > #audioVideoButton {
+  background-image: url("webRTC-camera-white-16.png");
+}
+
+window[sharingaudio] > #audioVideoButton {
+  background-image: url("webRTC-microphone-white-16.png");
+}
+
+/* Multi-icon button: */
+window[sharingaudio][sharingvideo] > #audioVideoButton {
+  background-image: url("webRTC-camera-white-16.png"),
+                    url("webRTC-microphone-white-16.png");
+  background-position: 6px center, 26px center;
+  background-size: 16px, 16px;
+  min-width: 46px;
+}
+
+/* Hover styles */
+#audioVideoButton,
+#screenShareButton {
+  background-color: #ffaa33;
+}
+
+#audioVideoButton:hover,
+#screenShareButton:hover {
+  background-color: #ff9500;
+}
+
+/* Don't show the dropmarker for the type="menu" case */
+#audioVideoButton > .box-inherit > .button-menu-dropmarker,
+#screenShareButton > .box-inherit > .button-menu-dropmarker {
+  display: none;
+}
+
+/* Separator in case of screen sharing + video/audio sharing */
+#shareSeparator {
+  width: 1px;
+  margin: 4px -1px 4px 0;
+  background-color: #FFCA80;
+  /* Separator needs to show above either button when they're hovered: */
+  position: relative;
+  z-index: 1;
+  display: none;
+}
+
+window[sharingscreen][sharingvideo] > #shareSeparator,
+window[sharingscreen][sharingaudio] > #shareSeparator {
+  display: -moz-box;
+}
+
+:-moz-any(#audioVideoButton, #screenShareButton,
+          #firefoxButton):-moz-focusring > .button-box {
+  border: none;
+}

diff --git a/platform/x11/ext.c b/platform/x11/ext.c
new file mode 100644
index 000000000..829ca9214
--- /dev/null
+++ b/platform/x11/ext.c
@@ -0,0 +1,127 @@
+void pdfapp_ext_nextprev(pdfapp_t *app, int next)
+{
+	FILE *fp;
+	char filename[PATH_MAX];
+	char cmdarg[PATH_MAX+256];
+	char *cmd;
+	if (!(cmd = getenv("MUPDF_NEXTPREV")))
+		return;
+
+	fz_snprintf(cmdarg, sizeof(cmdarg), "%s \"%s\" %d", cmd, app->docpath, next);
+
+	if ((fp = popen(cmdarg, "r")) == NULL) {
+		printf("Error opening pipe!\n");
+		return;
+	}
+
+	if (fgets(filename, sizeof filename, fp)) {
+		pdfapp_close(app);
+		pdfapp_open(app, filename, 1);
+	}
+
+	if (pclose(fp)) {
+		printf("Command not found or exited with error status\n");
+		return;
+	}
+
+	return;
+}
+
+void pdfapp_ext_search(pdfapp_t *app)
+{
+	FILE *fp;
+	char *cmd = getenv("MUPDF_SEARCH");
+	if (!cmd) cmd = "dmenu <&-";
+
+	if ((fp = popen(cmd, "r")) == NULL) {
+		printf("Error opening pipe!\n");
+		return;
+	}
+
+	if (fgets(app->search, sizeof app->search, fp))
+		app->search[strcspn(app->search, "\n")] = 0;
+
+	if (pclose(fp)) {
+		printf("Command not found or exited with error status\n");
+		return;
+	}
+
+	return;
+}
+
+int pdfapp_ext_outline(pdfapp_t *app)
+{
+	FILE *fp;
+	char buf[256];
+	char cmdarg[PATH_MAX+256];
+	char *cmd;
+	if (!(cmd = getenv("MUPDF_OUTLINE")))
+		return 0;
+
+	fz_snprintf(cmdarg, sizeof(cmdarg), "%s \"%s\" %d", cmd, app->docpath, app->pageno);
+
+	if ((fp = popen(cmdarg, "r")) == NULL) {
+		printf("Error opening pipe!\n");
+		return 0;
+	}
+
+	if (!fgets(buf, sizeof(buf), fp))
+		buf[0] = '0';
+
+	if (pclose(fp)) {
+		printf("Command not found or exited with error status\n");
+		return 0;
+	}
+
+	return atoi(buf);
+}
+
+int pdfapp_ext_command(pdfapp_t *app)
+{
+	FILE *fp;
+	char buf[256];
+	char cmdarg[PATH_MAX+256];
+	char *cmd;
+	if (!(cmd = getenv("MUPDF_COMMAND")))
+		return 0;
+
+	fz_snprintf(cmdarg, sizeof(cmdarg), "%s \"%s\" %d", cmd, app->docpath, app->pageno);
+
+	if ((fp = popen(cmdarg, "r")) == NULL) {
+		printf("Error opening pipe!\n");
+		return 0;
+	}
+
+	if (!fgets(buf, sizeof(buf), fp))
+		buf[0] = '0';
+
+	if (pclose(fp)) {
+		printf("Command not found or exited with error status\n");
+		return 0;
+	}
+
+	return atoi(buf);
+}
+
+void pdfapp_ext_save_history(pdfapp_t *app)
+{
+	FILE *fp;
+	char cmdarg[PATH_MAX+256];
+	char *cmd;
+	if (!(cmd = getenv("MUPDF_SAVEHIST")))
+		return;
+
+	if (app->docpath == NULL)
+		return;
+
+	fz_snprintf(cmdarg, sizeof(cmdarg), "%s \"%s\" %d %f", cmd, app->docpath, app->pageno, app->resolution);
+
+	if ((fp = popen(cmdarg, "r")) == NULL) {
+		printf("Error opening pipe!\n");
+		return;
+	}
+	if (pclose(fp)) {
+		printf("SAVEHIST: not found or exited with error status\n");
+		return;
+	}
+}
diff --git a/platform/x11/pdfapp.c b/platform/x11/pdfapp.c
index f45b0e71b..dbb33174a 100644
--- a/platform/x11/pdfapp.c
+++ b/platform/x11/pdfapp.c
@@ -21,6 +21,8 @@
 #define PATH_MAX 4096
 #endif
 
+#include "ext.c"
+
 #ifndef MAX
 #define MAX(a,b) ((a) > (b) ? (a) : (b))
 #endif
@@ -628,6 +630,7 @@ void pdfapp_open_progressive(pdfapp_t *app, char *filename, int reload, int kbps
 
 void pdfapp_close(pdfapp_t *app)
 {
+	pdfapp_ext_save_history(app);
 	fz_drop_display_list(app->ctx, app->page_list);
 	app->page_list = NULL;
 
@@ -787,12 +790,31 @@ static void pdfapp_panview(pdfapp_t *app, int newx, int newy)
 	if (newx > 0)
 		newx = 0;
 	if (newy > 0)
-		newy = 0;
-
+	{
+		if(app->pageno > 1 && app->continuous)
+		{
+			--app->pageno;
+			pdfapp_showpage(app, 1, 1, 0, 0, 0);
+			app->pany = newy = (app->winh-app->imgh>-app->pagedivh?
+								app->winh-app->imgh:-app->pagedivh)+newy;
+		}
+		else
+			newy = 0;
+	}
 	if (newx + app->imgw < app->winw)
 		newx = app->winw - app->imgw;
 	if (newy + app->imgh < app->winh)
-		newy = app->winh - app->imgh;
+	{
+		if(app->pageno < app->pagecount && app->continuous)
+		{
+			++app->pageno;
+			pdfapp_showpage(app, 1, 1, 0, 0, 0);
+			app->pany=newy=(app->winh-app->pagedivh < 0?app->winh-app->pagedivh:0)
+					+ (newy+app->imgh - app->winh);
+		}
+		else
+			newy = app->winh - app->imgh;
+	}
 
 	if (app->winw >= app->imgw)
 		newx = (app->winw - app->imgw) / 2;
@@ -832,6 +854,23 @@ static void pdfapp_loadpage(pdfapp_t *app, int no_cache)
 	app->page_bbox.x1 = 100;
 	app->page_bbox.y1 = 100;
 
+//page 1
+	if(app->continuous)
+	{
+		if (app->page1_list)
+			fz_drop_display_list(app->ctx, app->page1_list);
+		if (app->page1)
+			fz_drop_page(app->ctx, app->page1);
+
+		app->page1_list = NULL;
+		app->page1 = NULL;
+		app->page1_bbox.x0 = 0;
+		app->page1_bbox.y0 = 0;
+		app->page1_bbox.x1 = 100;
+		app->page1_bbox.y1 = 100;
+	}
+//page 1
+
 	app->incomplete = 0;
 
 	fz_try(app->ctx)
@@ -841,6 +880,17 @@ static void pdfapp_loadpage(pdfapp_t *app, int no_cache)
 			app->incomplete = 1;
 		app->page_bbox = fz_bound_page(app->ctx, app->page);
 		app->page_links = fz_load_links(app->ctx, app->page);
+		if(app->continuous)
+		{
+			if(app->pageno < app->pagecount)
+			{
+				app->page1 = fz_load_page(app->ctx, app->doc, app->pageno);
+				app->isnextpage = 1;
+			}
+			else app->isnextpage = 0;
+			app->page1_bbox = fz_bound_page(app->ctx, app->page1);
+		}
+
 	}
 	fz_catch(app->ctx)
 	{
@@ -904,6 +954,19 @@ static void pdfapp_loadpage(pdfapp_t *app, int no_cache)
 		fz_close_device(app->ctx, mdev);
 		fz_drop_device(app->ctx, mdev);
 		mdev = NULL;
+		//page 1
+		if(app->isnextpage && app->continuous)
+		{
+			app->page1_list = fz_new_display_list(app->ctx, fz_infinite_rect);
+			mdev = fz_new_list_device(app->ctx, app->page1_list);
+			if (no_cache)
+				fz_enable_device_hints(app->ctx, mdev, FZ_NO_CACHE);
+			fz_run_page_contents(app->ctx, app->page1, mdev, fz_identity, &cookie);
+			fz_close_device(app->ctx, mdev);
+			fz_drop_device(app->ctx, mdev);
+			mdev = NULL;
+		}
+		//page 1
 		app->annotations_list = fz_new_display_list(app->ctx, fz_infinite_rect);
 		mdev = fz_new_list_device(app->ctx, app->annotations_list);
 		fz_run_page_annots(app->ctx, app->page, mdev, fz_identity, &cookie);
@@ -935,10 +998,10 @@ static void pdfapp_loadpage(pdfapp_t *app, int no_cache)
 	app->errored = errored;
 }
 
-static void pdfapp_runpage(pdfapp_t *app, fz_device *dev, const fz_matrix ctm, fz_rect scissor, fz_cookie *cookie)
+static void pdfapp_runpage(pdfapp_t *app, fz_device *dev, const fz_matrix ctm, fz_rect scissor, fz_cookie *cookie, int next)
 {
 	if (app->page_list)
-		fz_run_display_list(app->ctx, app->page_list, dev, ctm, scissor, cookie);
+		fz_run_display_list(app->ctx, (next ? app->page1_list : app->page_list), dev, ctm, scissor, cookie);
 	if (app->annotations_list)
 		fz_run_display_list(app->ctx, app->annotations_list, dev, ctm, scissor, cookie);
 }
@@ -964,9 +1027,9 @@ static void pdfapp_showpage(pdfapp_t *app, int loadpage, int drawpage, int repai
 	fz_device *idev = NULL;
 	fz_device *tdev;
 	fz_colorspace *colorspace;
-	fz_matrix ctm;
-	fz_rect bounds;
-	fz_irect ibounds;
+	fz_matrix ctm,ctm1,ctm2;
+	fz_rect bounds, bounds1;
+	fz_irect ibounds, ibounds1;
 	fz_cookie cookie = { 0 };
 
 	if (!app->nowaitcursor)
@@ -1013,7 +1076,7 @@ static void pdfapp_showpage(pdfapp_t *app, int loadpage, int drawpage, int repai
 			tdev = fz_new_stext_device(app->ctx, app->page_text, NULL);
 			fz_try(app->ctx)
 			{
-				pdfapp_runpage(app, tdev, fz_identity, fz_infinite_rect, &cookie);
+				pdfapp_runpage(app, tdev, fz_identity, fz_infinite_rect, &cookie, 0);
 				fz_close_device(app->ctx, tdev);
 			}
 			fz_always(app->ctx)
@@ -1048,6 +1111,12 @@ static void pdfapp_showpage(pdfapp_t *app, int loadpage, int drawpage, int repai
 		bounds = fz_transform_rect(app->page_bbox, ctm);
 		ibounds = fz_round_rect(bounds);
 		bounds = fz_rect_from_irect(ibounds);
+		if(app->continuous)
+		{
+			bounds1 = fz_transform_rect(app->page1_bbox, ctm);
+			ibounds1 = fz_round_rect(bounds1);
+			bounds1 = fz_rect_from_irect(ibounds1);
+		}
 
 		/* Draw */
 		fz_drop_pixmap(app->ctx, app->image);
@@ -1060,6 +1129,16 @@ static void pdfapp_showpage(pdfapp_t *app, int loadpage, int drawpage, int repai
 		app->imgw = 0;
 		app->imgh = 0;
 
+		if(app->isnextpage && app->continuous)
+		{
+			app->pagedivh=ibounds.y1;
+			ibounds.y1 += ibounds1.y1;
+			if(ibounds1.x0 < ibounds.x0)
+				ibounds.x0 = ibounds1.x0;
+			if(ibounds1.x1 > ibounds.x1)
+				ibounds.x1 = ibounds1.x1;
+		}
+
 		fz_var(app->image);
 		fz_var(idev);
 
@@ -1073,13 +1152,22 @@ static void pdfapp_showpage(pdfapp_t *app, int loadpage, int drawpage, int repai
 			if (app->page_list || app->annotations_list)
 			{
 				idev = fz_new_draw_device(app->ctx, fz_identity, app->image);
-				pdfapp_runpage(app, idev, ctm, bounds, &cookie);
+				pdfapp_runpage(app, idev, ctm, bounds, &cookie, 0);
+				if(app->isnextpage && app->continuous && app->page1_list)
+				{
+					ctm1 = fz_translate(0, bounds.y1);
+					ctm2 = fz_concat(ctm, ctm1);
+					bounds1.y0 += bounds.y1;
+					bounds1.y1 += bounds.y1;
+					pdfapp_runpage(app, idev, ctm2, bounds1, &cookie, app->continuous);
+				}
+
 				fz_close_device(app->ctx, idev);
 			}
 			if (app->invert)
 			{
 				fz_invert_pixmap_luminance(app->ctx, app->image);
-				fz_gamma_pixmap(app->ctx, app->image, 1 / 1.4f);
+				fz_gamma_pixmap(app->ctx, app->image, 1.0f);
 			}
 			if (app->tint)
 				fz_tint_pixmap(app->ctx, app->image, 0, app->tint_white);
@@ -1425,7 +1513,10 @@ key_rewritten:
 		app->resolution = zoom_out(app->resolution);
 		pdfapp_showpage(app, 0, 1, 1, 0, 0);
 		break;
-
+	case 'K':
+		app->continuous ^=1;
+		pdfapp_showpage(app, 1, 1, 1, 0, 0);
+		break;
 	case 'W':
 		pdfapp_autozoom_horizontal(app);
 		break;
@@ -1436,6 +1527,7 @@ key_rewritten:
 		pdfapp_autozoom(app);
 		break;
 	case 'z':
+	case '=':
 		if (app->numberlen > 0)
 			app->resolution = atoi(app->number);
 		else
@@ -1443,14 +1535,14 @@ key_rewritten:
 		pdfapp_showpage(app, 0, 1, 1, 0, 0);
 		break;
 
-	case '[':
+	case '{':
 		if (app->numberlen > 0)
 			app->rotate -= atoi(app->number);
 		else
 			app->rotate -= 90;
 		pdfapp_showpage(app, 0, 1, 1, 0, 0);
 		break;
-	case ']':
+	case '}':
 		if (app->numberlen > 0)
 			app->rotate += atoi(app->number);
 		else
@@ -1537,31 +1629,37 @@ key_rewritten:
 		break;
 
 	case 'j':
+	case 'd':
+	case 0x04:
 		{
-			if (app->imgh <= app->winh || app->pany <= app->winh - app->imgh)
+			if (!app->continuous && (app->imgh <= app->winh || app->pany <= app->winh - app->imgh))
 			{
 				panto = PAN_TO_TOP;
 				app->pageno++;
 			}
 			else
 			{
-				app->pany -= app->imgh / 10;
+				app->pany -= app->imgh / (c == 'j' ? 10 : 5);
 				pdfapp_showpage(app, 0, 0, 1, 0, 0);
+				oldpage=app->pageno;
 			}
 			break;
 		}
 
 	case 'k':
+	case 'u':
+	case 0x15:
 		{
-			if (app->imgh <= app->winh || app->pany == 0)
+			if (!app->continuous && (app->imgh <= app->winh || app->pany == 0))
 			{
 				panto = PAN_TO_BOTTOM;
 				app->pageno--;
 			}
 			else
 			{
-				app->pany += app->imgh / 10;
+				app->pany += app->imgh / (c == 'k' ? 10 : 5);
 				pdfapp_showpage(app, 0, 0, 1, 0, 0);
+				oldpage=app->pageno;
 			}
 			break;
 		}
@@ -1580,10 +1678,18 @@ key_rewritten:
 			pdfapp_gotopage(app, atoi(app->number));
 		else
 			pdfapp_gotopage(app, 1);
+		app->pany = 0;
+		pdfapp_showpage(app, 0, 0, 1, 0, 0);
 		break;
 
 	case 'G':
-		pdfapp_gotopage(app, app->pagecount);
+		if (app->numberlen > 0)
+			pdfapp_gotopage(app, atoi(app->number));
+		else
+			pdfapp_gotopage(app, app->pagecount);
+		app->pany = INT_MIN;
+		pdfapp_showpage(app, 0, 0, 1, 0, 0);
+		panto = PAN_TO_BOTTOM;
 		break;
 
 	case 'm':
@@ -1622,6 +1728,15 @@ key_rewritten:
 		app->presentation_time_in_seconds = (app->numberlen > 0) ? atoi(app->number) : 5;
 		break;
 
+	case 'o':
+		int n;
+		if (n = pdfapp_ext_outline(app)) {
+			pdfapp_gotopage(app, n);
+			app->pany = 0;
+		}
+		/* pdfapp_showpage(app, 0, 0, 1, 0, 0); */
+		break;
+
 	/*
 	 * Back and forth ...
 	 */
@@ -1729,6 +1844,22 @@ key_rewritten:
 		pdfapp_reloadfile(app);
 		break;
 
+	case ']':
+	case 0x0e:
+		panto = PAN_TO_TOP;
+		oldpage = -1;
+		pdfapp_ext_nextprev(app, 1);
+		pdfapp_gotopage(app, 1);
+		break;
+
+	case '[':
+	case 0x10:
+		panto = PAN_TO_TOP;
+		oldpage = -1;
+		pdfapp_ext_nextprev(app, 0);
+		pdfapp_gotopage(app, 1);
+		break;
+
 	/*
 	 * Searching
 	 */
@@ -1742,7 +1873,7 @@ key_rewritten:
 		winrepaintsearch(app);
 		break;
 
-	case '/':
+	case 0x1f:
 		app->issearching = 1;
 		app->searchdir = 1;
 		app->search[0] = 0;
@@ -1751,6 +1882,16 @@ key_rewritten:
 		winrepaintsearch(app);
 		break;
 
+	case '/':
+		app->searchdir = 1;
+		app->search[0] = 0;
+		app->hit_count = 0;
+		app->searchpage = -1;
+		pdfapp_ext_search(app);
+		pdfapp_search_in_direction(app, &panto, 1);
+		loadpage = 0;
+		break;
+
 	case 'n':
 		if (app->searchdir > 0)
 			pdfapp_search_in_direction(app, &panto, 1);
@@ -1784,7 +1925,10 @@ key_rewritten:
 			app->pany = 0;
 			break;
 		case PAN_TO_BOTTOM:
-			app->pany = INT_MIN;
+			if(app->continuous)
+				app->pany = app->winh-app->imgh/2 < 0 ? app->winh-app->imgh/2 : 0;
+			else
+				app->pany = INT_MIN;
 			break;
 		case DONT_PAN:
 			break;
diff --git a/platform/x11/pdfapp.h b/platform/x11/pdfapp.h
index e035206a2..5c686b85c 100644
--- a/platform/x11/pdfapp.h
+++ b/platform/x11/pdfapp.h
@@ -103,6 +103,7 @@ struct pdfapp_s
 	int useicc;
 	int useseparations;
 	int aalevel;
+	int continuous;
 
 	/* presentation mode */
 	int presentation_mode;
@@ -118,8 +119,13 @@ struct pdfapp_s
 	/* current page params */
 	int pageno;
 	fz_page *page;
+	int isnextpage;
+	int pagedivh;
+	fz_page *page1;
 	fz_rect page_bbox;
+	fz_rect page1_bbox;
 	fz_display_list *page_list;
+	fz_display_list *page1_list;
 	fz_display_list *annotations_list;
 	fz_stext_page *page_text;
 	fz_link *page_links;
diff --git a/platform/x11/x11_main.c b/platform/x11/x11_main.c
index 84ae0a4ab..6ef50c687 100644
--- a/platform/x11/x11_main.c
+++ b/platform/x11/x11_main.c
@@ -113,6 +113,7 @@ static int dirty = 0;
 static int transition_dirty = 0;
 static int dirtysearch = 0;
 static char *password = "";
+static int embed = 0;
 static XColor xbgcolor;
 static int reqw = 0;
 static int reqh = 0;
@@ -219,6 +220,7 @@ static void winopen(void)
 {
 	XWMHints *wmhints;
 	XClassHint *classhint;
+	Window parent;
 
 #ifdef HAVE_CURL
 	if (!XInitThreads())
@@ -248,13 +250,14 @@ static void winopen(void)
 	xcwait = XCreateFontCursor(xdpy, XC_watch);
 	xccaret = XCreateFontCursor(xdpy, XC_xterm);
 
-	xbgcolor.red = 0x7000;
-	xbgcolor.green = 0x7000;
-	xbgcolor.blue = 0x7000;
+	xbgcolor.red = 0x0000;
+	xbgcolor.green = 0x0000;
+	xbgcolor.blue = 0x0000;
 
 	XAllocColor(xdpy, DefaultColormap(xdpy, xscr), &xbgcolor);
 
-	xwin = XCreateWindow(xdpy, DefaultRootWindow(xdpy),
+	parent = embed ? embed : DefaultRootWindow(xdpy);
+	xwin = XCreateWindow(xdpy, parent,
 		10, 10, 200, 100, 0,
 		ximage_get_depth(),
 		InputOutput,
@@ -907,7 +910,7 @@ int main(int argc, char **argv)
 
 	pdfapp_init(ctx, &gapp);
 
-	while ((c = fz_getopt(argc, argv, "Ip:r:A:C:W:H:S:U:Xb:")) != -1)
+	while ((c = fz_getopt(argc, argv, "IKp:r:A:C:W:H:S:U:Xb:w:")) != -1)
 	{
 		switch (c)
 		{
@@ -919,6 +922,7 @@ int main(int argc, char **argv)
 		case 'p': password = fz_optarg; break;
 		case 'r': resolution = atoi(fz_optarg); break;
 		case 'I': gapp.invert = 1; break;
+		case 'K': gapp.continuous = 1; break;
 		case 'A': fz_set_aa_level(ctx, atoi(fz_optarg)); break;
 		case 'W': gapp.layout_w = fz_atof(fz_optarg); break;
 		case 'H': gapp.layout_h = fz_atof(fz_optarg); break;
@@ -926,6 +930,7 @@ int main(int argc, char **argv)
 		case 'U': gapp.layout_css = fz_optarg; break;
 		case 'X': gapp.layout_use_doc_css = 0; break;
 		case 'b': kbps = fz_atoi(fz_optarg); break;
+		case 'w': embed = strtol(fz_optarg, NULL, 0); break;
 		default: usage(argv[0]);
 		}
 	}
